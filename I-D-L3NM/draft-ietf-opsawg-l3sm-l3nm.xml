<?xml version="1.0" encoding="US-ASCII"?>
<!-- This template is for creating an Internet Draft using xml2rfc,
     which is available here: http://xml2rfc.tools.ietf.org. -->
<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!-- One method to get references from the online citation libraries.
     There has to be one entity for each item to be referenced.
     An alternate method (rfc include) is described in the references. -->
<!ENTITY RFC2119 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC3688 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3688.xml">
<!ENTITY RFC4026 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4026.xml">
<!ENTITY RFC4176 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4176.xml">
<!ENTITY RFC6020 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6020.xml">
<!ENTITY RFC6241 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6241.xml">
<!ENTITY RFC6242 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6242.xml">
<!ENTITY RFC6991 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6991.xml">
<!ENTITY RFC7950 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7950.xml">
<!ENTITY RFC8040 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8040.xml">
<!ENTITY RFC8174 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml">
<!ENTITY RFC8277 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8277.xml">
<!ENTITY RFC8299 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8299.xml">
<!ENTITY RFC8294 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8294.xml">
<!ENTITY RFC8309 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8309.xml">
<!ENTITY RFC8340 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8340.xml">
<!ENTITY RFC8341 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8341.xml">
<!ENTITY RFC8466 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8466.xml">
<!ENTITY RFC8453 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8453.xml">
<!ENTITY RFC8512 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8512.xml">
<!ENTITY RFC8519 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8519.xml">
<!ENTITY RFC8349 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8349.xml">
<!ENTITY RFC8345 SYSTEM "http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8345.xml">
]>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!-- used by XSLT processors -->
<!-- For a complete list and description of processing instructions (PIs),
     please see http://xml.resource.org/authoring/README.html. -->
<!-- Below are generally applicable Processing Instructions (PIs) that most I-Ds might want to use.
     (Here they are set differently than their defaults in xml2rfc v1.32) -->
<?rfc strict="yes" ?>
<!-- give errors regarding ID-nits and DTD validation -->
<!-- control the table of contents (ToC) -->
<?rfc toc="yes"?>
<!-- generate a ToC -->
<?rfc tocdepth="5"?>
<!-- the number of levels of subsections in ToC. default: 3 -->
<!-- control references -->
<?rfc symrefs="yes"?>
<!-- use symbolic references tags, i.e, [RFC2119] instead of [1] -->
<?rfc sortrefs="yes" ?>
<!-- sort the reference entries alphabetically -->
<!-- control vertical white space
     (using these PIs as follows is recommended by the RFC Editor) -->
<?rfc compact="yes" ?>
<!-- do not start each main section on a new page -->
<?rfc subcompact="no" ?>
<!-- keep one blank line between list items -->
<!-- end of list of popular I-D processing instructions -->
<rfc category="std" docName="draft-ietf-opsawg-l3sm-l3nm-05" ipr="trust200902">
  <!-- category values: std, bcp, info, exp, and historic
     ipr values: full3667, noModification3667, noDerivatives3667
     you can add the attributes updates="NNNN" and obsoletes="NNNN"
     they will automatically be output with "(if approved)" -->

  <!-- ***** FRONT MATTER ***** -->

  <front>
    <!-- The abbreviated title is used in the page header - it is only necessary if the
         full title is longer than 39 characters -->

    <title abbrev="L3NM">A Layer 3 VPN Network YANG Model</title>

    <author fullname="Samier Barguil" initials="S.B." surname="Barguil">
      <organization>Telefonica</organization>

      <address>
        <postal>
          <street></street>

          <!-- Reorder these if your country does things differently -->

          <city>Madrid</city>

          <region></region>

          <code></code>

          <country>ES</country>
        </postal>

        <phone></phone>

        <email>samier.barguilgiraldo.ext@telefonica.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Oscar Gonzalez de Dios" initials="O.G.D" role="editor"
            surname="Gonzalez de Dios">
      <organization>Telefonica</organization>

      <address>
        <postal>
          <street></street>

          <!-- Reorder these if your country does things differently -->

          <city>Madrid</city>

          <region></region>

          <code></code>

          <country>ES</country>
        </postal>

        <phone></phone>

        <email>oscar.gonzalezdedios@telefonica.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Mohamed Boucadair" initials="M." role="editor"
            surname="Boucadair">
      <organization>Orange</organization>

      <address>
        <postal>
          <street>Rennes 35000</street>

          <country>France</country>
        </postal>

        <email>mohamed.boucadair@orange.com</email>
      </address>
    </author>

    <author fullname="Luis Angel Munoz" initials="L.A." surname="Munoz">
      <organization>Vodafone</organization>

      <address>
        <postal>
          <street></street>

          <!-- Reorder these if your country does things differently -->

          <city></city>

          <region></region>

          <code></code>

          <country>ES</country>
        </postal>

        <phone></phone>

        <email>luis-angel.munoz@vodafone.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <author fullname="Alejandro Aguado" initials="A.A." surname="Aguado">
      <organization>Nokia</organization>

      <address>
        <postal>
          <street></street>

          <!-- Reorder these if your country does things differently -->

          <city>Madrid</city>

          <region></region>

          <code></code>

          <country>ES</country>
        </postal>

        <phone></phone>

        <email>alejandro.aguado_martin@nokia.com</email>

        <!-- uri and facsimile elements may also be added -->
      </address>
    </author>

    <date />

    <!-- Meta-data Declarations -->

    <area>ops</area>

    <workgroup>OPSAWG</workgroup>

    <!-- WG name at the upperleft corner of the doc,
         IETF is fine for individual submissions.
  If this element is not present, the default is "Network Working Group",
         which is used by the RFC Editor as a nod to the history of the IETF. -->

    <keyword>l3vpn</keyword>

    <!-- Keywords will be incorporated into HTML output
         files in a meta tag but they have no effect on text or nroff
         output. If you submit your draft to the RFC Editor, the
         keywords will be used for the search engine. -->

    <abstract>
      <t>This document defines a L3VPN Network YANG Model (L3NM) that can be
      used for the provisioning of Layer 3 Virtual Private Network (VPN)
      services within a service provider's network. The model provides a
      network-centric view of L3VPN services.</t>

      <t>L3NM is meant to be used by a network controller to derive the
      configuration information that will be sent to relevant network devices.
      The model can also facilitate the communication between a service
      orchestrator and a network controller/orchestrator.</t>
    </abstract>

    <note title="Editorial Note (To be removed by RFC Editor)">
      <t>Please update these statements within the document with the RFC
      number to be assigned to this document:<list style="symbols">
          <t>"This version of this YANG module is part of RFC XXXX;"</t>

          <t>"RFC XXXX: Layer 3 VPN Network Model";</t>

          <t>reference: RFC XXXX</t>
        </list></t>

      <t>Also, please update the "revision" date of the YANG module.</t>
    </note>
  </front>

  <middle>
    <section title="Introduction">
      <t><xref target="RFC8299"></xref> defines a Layer 3 Virtual Private
      Network Service YANG data Model (L3SM) that can be used for
      communication between customers and network operators. Such model is
      focused on describing the customer view of the Virtual Private Network
      (VPN) services and provides an abstracted view of the customer's
      requested services. That approach limits the usage of the L3SM to the
      role of a Customer Service Model (as per <xref
      target="RFC8309"></xref>).</t>

      <t>This document defined a YANG module called L3VPN Network Model
      (L3NM). The L3NM is aimed at providing a network-centric view of Layer 3
      (L3) VPN services. This data model can be used to facilitate
      communication between the service orchestrator (or a network operator)
      and the network controller/orchestrator by allowing for more
      network-centric information to be included. It enables further
      capabilities, such as resource management or to serve as a multi-domain
      orchestration interface, where logical resources (such as route targets
      or route distinguishers) must be coordinated.</t>

      <t>This document uses the common VPN YANG module defined in <xref
      target="I-D.ietf-opsawg-vpn-common"></xref>.</t>

      <t>This document does not obsolete <xref target="RFC8299"></xref>. These
      two modules are used for similar objectives but with different scopes
      and views.</t>

      <t>The L3NM YANG module is initially built with a prune and extend
      approach, taking as a starting points the YANG module described in <xref
      target="RFC8299"></xref>. Nevertheless,the L3NM is not defined as an
      augment to L3SM because a specific structure is required to meet
      network-oriented L3 needs.</t>

      <t>Some of the information captured in the L3SM can be passed by the
      Orchestrator in the L3NM (e.g., customer) or be used to fed some of the
      L3NM attributes (e.g., actual forwarding policies). Some of the
      information captured in L3SM may be maintained locally within the
      Orchestrator; which is in charge of maintaining the correspondence
      between a customer view and its network instantiation. Likewise, some of
      the information captured and exposed using the L3NM can feed the service
      layer (e.g., capabilities) to drive VPN service order handling, and thus
      the L3SM.</t>

      <t>The L3NM does not attempt to address all deployment cases especially
      those where the L3VPN connectivity is supported through the coordination
      of different VPNs in different underlying networks. More complex
      deployment scenarios involving the coordination of different VPN
      instances and different technologies to provide an end-to-end VPN
      connectivity are addressed by complementary YANG modules, e.g., <xref
      target="I-D.evenwu-opsawg-yang-composed-vpn"></xref>.</t>

      <t>L3NM focuses on BGP Provider Edge (PE) based Layer 3 VPNs as
      described in <xref target="RFC4026"></xref><xref
      target="RFC4110"></xref><xref target="RFC4364"></xref> and Multicast
      VPNs as described in <xref target="RFC6037"></xref><xref
      target="RFC6513"></xref><xref target="RFC7988"></xref>.</t>

      <t>The YANG data model in this document conforms to the Network
      Management Datastore Architecture (NMDA) defined in <xref
      target="RFC8342"></xref>.</t>
    </section>

    <section anchor="terminology" title="Terminology">
      <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
      "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
      "OPTIONAL" in this document are to be interpreted as described in BCP 14
      <xref target="RFC2119"></xref> <xref target="RFC8174"></xref> when, and
      only when, they appear in all capitals, as shown here.</t>

      <t>This document assumes that the reader is familiar with the contents
      of <xref target="RFC6241"></xref>, <xref target="RFC7950"></xref>, <xref
      target="RFC8299"></xref>, <xref target="RFC8309"></xref>, and <xref
      target="RFC8453"></xref> and uses the terminology defined in those
      documents.</t>

      <t>The meaning of the symbols in the tree diagrams is defined in <xref
      target="RFC8340"></xref>.</t>

      <t>This document makes use of the following terms:</t>

      <t><list style="hanging">
          <t hangText="Layer 3 VPN Customer Service Model (L3SM):">A YANG
          module that describes the service requirements of a L3VPN that
          interconnects a set of sites from the point of view of the customer.
          The customer service model does not provide details on the service
          provider network. The L3VPN Customer Service model is defined in
          <xref target="RFC8299"></xref>.</t>

          <t hangText="Layer 3 VPN Service Network Model (L3NM):">A YANG
          module that describes a VPN service in the service provider network.
          It contains information of the service provider network and might
          include allocated resources. It can be used by network controllers
          to manage and control the VPN service configuration in the service
          provider network. The YANG module can be consumed by a service
          orchestrator to request a VPN service to a Network Controller.</t>

          <t hangText="Service orchestrator:">A functional entity that
          interacts with the customer of a L3VPN. The service orchestrator
          interacts with the customer using the L3SM. The service orchestrator
          is responsible of the Customer Edge (CE) - Provider Edge (PE)
          attachment circuits, the PE selection, and requesting the VPN
          service to the Network Controller.</t>

          <t hangText="Network orchestrator:">A functional entity that is
          hierarchically intermediate between a service orchestrator and
          network nontrollers. A network orchestrator can manage one or
          several network nontrollers.</t>

          <t hangText="Network controller:">A functional entity responsible
          for the control and management of the service provider network.</t>

          <t hangText="VPN node:">An abstraction that represents a set of
          policies applied on a PE and that belong to a single VPN service. A
          VPN service involves one or more VPN nodes. As it is an abstraction,
          the network controller will take on how to implement a VPN node. For
          example, typically, in a BGP-based VPN, a VPN node could be mapped
          into a Virtual Routing and Forwarding (VRF).</t>

          <t hangText="VPN network access:">An abstraction that represents the
          network interfaces that are associated to a given VPN node. Traffic
          coming from the VPN network access belongs to the VPN. The
          attachment circuits (bearers) between CEs and PEs are terminated in
          the VPN network access. A reference to the bearer is maintained to
          allow keeping the link between L3SM and L3NM.</t>

          <t hangText="VPN site: ">A VPN customer's location that is connected
          to the service provider network via a CE-PE link, which can access
          at least one VPN <xref target="RFC4176"></xref>.</t>

          <t hangText="VPN service provider:">A service provider that offers
          VPN-related services <xref target="RFC4176"></xref>.</t>

          <t hangText="Service provider network:">A network that is able to
          provide VPN-related services.</t>
        </list></t>

      <t>The document is aimed at modeling BGP PE-based VPNs in a service
      provider network, so the terms defined in <xref target="RFC4026"></xref>
      and <xref target="RFC4176"></xref> are used.</t>
    </section>

    <section anchor="ref" title="L3NM Reference Architecture">
      <t><xref target="xml_happy"></xref> depicts the reference architecture
      for the L3NM. The figure is an expansion of the architecture presented
      in Section 5 of <xref target="RFC8299"></xref>; it decomposes the box
      marked "orchestration" in that section into three separate functional
      components: Service Orchestration, Network Orchestration, and Domain
      Orchestration.</t>

      <t>Although some deployments may choose to construct a monolithic
      orchestration component (covering both service and network matters),
      this document advocates for a clear separation between service and
      network orchestration components for the sake of better flexibility.
      Such design adheres to the L3VPN reference architecture defined in
      Section 1.3 of <xref target="RFC4176"></xref>. This separation relies
      upon a dedicated communication interface between these components and
      appropriate YANG module that reflect network-related information (that
      is hidden to customers).</t>

      <t>The intelligence for translating customer-facing information into
      network-centric one is implementation specific.</t>

      <t>The terminology from <xref target="RFC8309"></xref> is introduced to
      show the distinction between the customer service model, the service
      delivery model, the network configuration model, and the device
      configuration model. In that context, the "Domain Orchestration" and
      "Config Manager" roles may be performed by "Controllers".</t>

      <figure align="center" anchor="xml_happy" title="Reference Architecture">
        <artwork align="center"><![CDATA[
                                  +---------------+
                                  |   Customer    |
                                  +---------------+
                  Customer Service Model  |
                         l3vpn-svc        |
                                  +---------------+
                                  |    Service    |
                                  | Orchestration |
                                  +---------------+
                    L3NM Network Model    |
                       l3vpn-ntw          |
                                  +---------------+
                                  |   Network     |
                                  | Orchestration |
                                  +---------------+
            Network Configuration Model   |
                              +-----------+-----------+
                              |                       |
                     +---------------+       +---------------+
                     |    Domain     |       |     Domain    |
                     | Orchestration |       | Orchestration |
                     +---------------+       +---------------+
          Device         |        |                   |
          Configuration  |        |                   |
          Model          |        |                   |
                    +---------+   |                   |
                    | Config  |   |                   |
                    | Manager |   |                   |
                    +---------+   |                   |
                         |        |                   |
                         | NETCONF/CLI..................
                         |        |                   |
                  +------------------------------------------------+
                                      Network
            ]]></artwork>
      </figure>

      <t>The L3SM and the L3NM may also be used in the context of the
      Abstraction and Control of TE Networks (ACTN) architecture <xref
      target="RFC8453"></xref>. <xref target="l3sm_actn"></xref> shows the
      Customer Network Controller (CNC), the Multi-Domain Service Coordinator
      (MDSC), and the Provisioning Network Controller (PNC). It also shows the
      interfaces between these functional blocks: the CNC-MDSC Interface
      (CMI), the MDSC-PNC Interface (MPI), and the Southbound Interface
      (SBI).</t>

      <figure align="center" anchor="l3sm_actn"
              title="L3SM and L3NM in the Context of ACTN">
        <artwork align="center"><![CDATA[
               +----------------------------------+
               | Customer                         |
               | +-----------------------------+  |
               | |             CNC             |  |
               | +-----------------------------+  |
               +----:-----------------------:-----+
                    :                       :
                    : L3SM                  : L3SM
                    :                       :
          +---------:---------+   +-------------------+
          | MDSC    :         |   |       MDSC        |
          | +---------------+ |   |     (parent)      |
          | |    Service    | |   +-------------------+
          | | Orchestration | |             :
          | +---------------+ |             : L3NM
          |         :         |             :
          |         : L3NM    |   +-------------------+
          |         :         |   |       MDSC        |
          | +---------------+ |   |      (child)      |
          | |    Network    | |   +-------------------+
          | | Orchestration | |             :
          | +---------------+ |             :
          +---------:---------+             :
                    :                       :
                    : Network Configuration :
                    :                       :
       +------------:-------+     +---------:------------+
       | Domain     :       |     |         : Domain     |
       | Controller :       |     |         : Controller |
       |       +---------+  |     |    +---------+       |
       |       |   PNC   |  |     |    |   PNC   |       |
       |       +---------+  |     |    +---------+       |
       +------------:-------+     +---------:------------+
                    :                       :
                    : Device Configuration  :
                    :                       :
               +--------+              +--------+
               | Device |              | Device |
               +--------+              +--------+
            ]]></artwork>
      </figure>
    </section>

    <section anchor="relation" title="Relation with other YANG Models">
      <t>The "ietf-vpn-common" module <xref
      target="I-D.ietf-opsawg-vpn-common"></xref> includes a set of
      identities, types, and groupings that are meant to be reused by
      VPN-related YANG modules independently of the layer (e.g., Layer 2,
      Layer 3) and the type of the module (e.g., network model, service model)
      including future revisions of existing models (e.g., <xref
      target="RFC8299"></xref> or <xref target="RFC8466"></xref>). The L3NM
      reuses these common types and groupings.</t>

      <t>In order to avoid data duplication and to ease passing data between
      layers when required (service layer to network layer and vice versa),
      early versions of the L3NM reused many of the data nodes that are
      defined in <xref target="RFC8299"></xref>. Nevertheless, that approach
      was abandoned in favor of the "ietf-vpn-common" module because that
      initial design was interpreted as if the deployment of L3NM depends on
      L3SM, while this is not the case. For example, a service provider may
      decide to use the L3NM to build its L3VPN services without exposing the
      L3SM.</t>

      <t>As discussed in <xref target="ref"></xref>, the L3NM is meant to
      manage L3VPN services within a service provider network. The module
      provides a network view of the service. Such view is only visible within
      the service provider and is not exposed outside (to customers, for
      example). The following discusses how L3NM interfaces with other YANG
      modules:</t>

      <t><list style="hanging">
          <t hangText="L3SM:">L3NM is not a customer service model.<vspace
          blankLines="1" />The internal view of the service (i.e., L3NM) may
          be mapped to an external view which is visible to customers: L3VPN
          Service YANG data Model (L3SM) <xref target="RFC8299"></xref>.
          <vspace blankLines="1" />Typically, the L3NM can be fed with inputs
          that are requested by customers, typically, relying upon a L3SM
          template. Concretely, some parts of the L3SM module can be directly
          mapped into L3NM while other parts are generated as a function of
          the requested service and local guidelines. Some other parts are
          local to the service provider and do not map directly to
          L3SM.<vspace blankLines="1" />Note that the use of L3NM within a
          service provider does not assume nor preclude exposing the VPN
          service via L3SM. This is deployment-specific. Nevertheless, the
          design of L3NM tries to align as much as possible with the features
          supported by the L3SM to ease grafting both L3NM and L3SM for the
          sake of highly automated VPN service provisioning and delivery.</t>

          <t hangText="Network Topology Modules:">A L3VPN involves nodes that
          are part of a topology managed by the service provider network. Such
          topology can be represented as using the network topology module in
          <xref target="RFC8345"></xref>.</t>

          <t hangText="Device Modules:">L3NM is not a device model. <vspace
          blankLines="1" />Once a global VPN service is captured by means of
          L3NM, the actual activation and provisioning of the VPN service will
          involve a variety of device modules to tweak the required functions
          for the delivery of the service. These functions are supported by
          the VPN nodes and can be managed using device YANG modules. A
          non-comprehensive list of such device YANG modules is provided
          below:<list style="symbols">
              <t>Routing management <xref target="RFC8349"></xref>.</t>

              <t>BGP <xref target="I-D.ietf-idr-bgp-model"></xref>.</t>

              <t>PIM <xref target="I-D.ietf-pim-yang"></xref>.</t>

              <t>NAT management <xref target="RFC8512"></xref>.</t>

              <t>QoS management <xref
              target="I-D.ietf-rtgwg-qos-model"></xref>.</t>

              <!---->

              <t>ACLs <xref target="RFC8519"></xref>.</t>
            </list><vspace blankLines="1" />How L3NM is used to derive
          device-specific actions is implementation-specific.</t>
        </list></t>
    </section>

    <section anchor="Use_of_the_data_model"
             title="Sample Uses of the L3NM Data Model">
      <t>This section provides a non-exhaustive list of examples to illustrate
      contexts where the L3NM can be used.</t>

      <section anchor="enterprise_services"
               title="Enterprise Layer 3 VPN Services">
        <t>Enterprise L3VPNs are one of the most demanded services for
        carriers, and therefore, L3NM can be useful to automate the
        provisioning and maintenance of these VPNs. Templates and batch
        processes can be built, and as a result many parameters are needed for
        the creation from scratch of a VPN that can be abstracted to the upper
        Software-Defined Networking (SDN) <xref target="RFC7149"></xref><xref
        target="RFC7426"></xref> layer and little manual intervention will be
        still required.</t>

        <t>Also common addition and/or removal of sites of an existing
        customer VPN can benefit of using L3NM by creation of workflows that
        either prune or add nodes as required from the network data mode.</t>
      </section>

      <section anchor="mdrmanagement" title="Multi-Domain Resource Management">
        <t>The implementation of L3VPN services which span across
        administratively separated domains (i.e., that are under the
        administration of different management systems or controllers)
        requires some network resources to be synchronized between systems.
        Particularly, there are two resources that must be orchestrated and
        manage to avoid asymmetric (non-functional) configuration, or the
        usage of unavailable resources.</t>

        <t>For example, route targets (RTs) shall be synchronized between PEs.
        When all PEs are controlled by the same management system, RT
        allocation can be performed by that management system. In cases where
        the service spans across multiple management systems, the task of
        allocating RTs has to be aligned across the domains, therefore, the
        service model must provide a way to specify RTs. In addition, route
        distinguishers (RDs) must also be synchronized to avoid collisions in
        RD allocation between separate management systems. An incorrect
        allocation might lead to the same RD and IP prefixes being exported by
        different PEs.</t>
      </section>

      <section anchor="ms_management" title="Management of Multicast Services">
        <t>Multicast services over L3VPN can be implemented using dual PIM
        MVPNs (also known as, Draft Rosen model) <xref
        target="RFC4364"></xref> or multiprotocol BGP (MBGP)-based MVPNs<xref
        target="RFC6513"> </xref><xref target="RFC6514"></xref>. Both methods
        are supported and equally effective, but the main difference is that
        MBGP-based MVPN does not require multicast configuration on the
        service provider network. MBGP MVPNs employ the intra-autonomous
        system BGP control plane and PIM sparse mode as the data plane. The
        PIM state information is maintained between PEs using the same
        architecture that is used for unicast VPNs.</t>

        <t>On the other hand, Draft Rosen has limitations such as reduced
        options for transport, control plane scalability, availability,
        operational inconsistency, and the need of maintaining state in the
        backbone. Because of this, MBGP MVPN is the architectural model that
        has been taken as the base for implementing multicast service on
        L3VPN. In this scenario, BGP auto discovery is used to discover MVPN
        PE members and the customer PIM signaling is sent across provider core
        through MP-BGP. The multicast traffic is transported on MPLS P2MP
        LSPs. All of the previous information is carried in the MCAST-VPN BGP
        NRLI.</t>
      </section>
    </section>

    <section anchor="YANG_explanation"
             title="Description of the L3NM YANG Module">
      <t>The L3NM ('ietf-l3vpn-ntw') is defined to manage L3VPNs in a service
      provider network. In particular, the 'ietf-l3vpn-ntw' module can be used
      to create, modify, and retrieve L3VPN Services of a network.</t>

      <t>The full tree diagram of the module can be generated using the
      "pyang" tool <xref target="PYANG"></xref>. That tree is not included
      here because it is too long (Section 3.3 of <xref
      target="RFC8340"></xref>). Instead, subtrees are provided for the
      reader's convenience.</t>

      <section anchor="structure_model"
               title="Overall Structure of the Module">
        <t>The 'ietf-l3vpn-ntw' module uses two main containers:
        'vpn-services' and 'vpn-profiles' (see <xref
        target="ietf-l3vpn-ntw_tree"></xref>).</t>

        <t>The 'vpn-services' container maintains the set of VPN services
        managed within the service provider's network. 'vpn-service' is the
        data structure that abstracts a VPN service (<xref
        target="vpn_service"></xref>).</t>

        <t>The 'vpn-profiles' container is used by the provider to maintain a
        set of common VPN profiles that apply to one or several VPN services
        (<xref target="vpn_profiles"></xref>).</t>

        <figure align="center" anchor="ietf-l3vpn-ntw_tree"
                title="Overall L3NM Tree Structure">
          <artwork align="center"><![CDATA[module: ietf-l3vpn-ntw
  +--rw l3vpn-ntw
     +--rw vpn-profiles
     |  ...
     +--rw vpn-services
         +--rw vpn-service* [vpn-id]
            ...     ]]></artwork>
        </figure>

        <t></t>
      </section>

      <section anchor="vpn_profiles" title="VPN Profiles">
        <t>The 'vpn-profiles' container (<xref
        target="vpn_profiles_tree"></xref>) allows the network provider to
        define and maintain a set of common VPN profiles <xref
        target="I-D.ietf-opsawg-vpn-common"></xref> that apply to one or
        several VPN services. The exact definition of the profiles is local to
        each network provider.</t>

        <t>This document does not make any assumption about the exact
        definition of these profiles. How such profiles are defined is
        deployment specific. The model only includes an identifier to these
        profiles to ease identifying and binding local policies when building
        a VPN service. As shown in <xref target="vpn_profiles_tree"></xref>,
        the following identifiers can be included:<list style="hanging">
            <t hangText="'external-connectivity-identifier':">This identifier
            refers to a profile that defines external connectivity provided to
            a VPN service (or a subset of VPN sites). An external connectivity
            may be access to Internet or restricted connectivity such as
            access to a public/private cloud.</t>

            <t hangText="'encryption-profile-identifier':">An encryption
            profile refers to a set of policies related to the encryption
            scheme(s) and setup that can be applied when building and offering
            a VPN service.</t>

            <t hangText="'qos-profile-identifier':">A Quality of Service (QoS)
            profile refers to as set of policies such as classification,
            marking, and actions (e.g., <xref target="RFC3644"></xref>).</t>

            <t hangText="'bfd-profile-identifier':">A Bidirectional Forwarding
            Detection (BFD) profile refers to a set of BFD <xref
            target="RFC5880"></xref> policies that can be invoked when
            building a VPN service.</t>

            <t hangText="'forwarding-profile-identifier':">A forwarding
            profile refers to the policies that apply to the forwarding of
            packets conveyed within a VPN. Such policies may consist, for
            example, at applying Access Control Lists (ACLs).</t>

            <t hangText="'routing-profile-identifier':">A routing profile
            refers to a set of routing policies that will be invoked (e.g.,
            BGP policies) when delivering the VPN service.</t>
          </list></t>

        <figure align="center" anchor="vpn_profiles_tree"
                title="VPN Profiles Subtree Structure">
          <artwork align="center"><![CDATA[  +--rw l3vpn-ntw
     +--rw vpn-profiles
     |  +--rw valid-provider-identifiers
     |     +--rw external-connectivity-identifier* [id]
     |     |       {external-connectivity}?
     |     |  +--rw id    string
     |     +--rw encryption-profile-identifier* [id]
     |     |  +--rw id    string
     |     +--rw qos-profile-identifier* [id]
     |     |  +--rw id    string
     |     +--rw bfd-profile-identifier* [id]
     |     |  +--rw id    string
     |     +--rw forwarding-profile-identifier* [id]
     |     |  +--rw id    string
     |     +--rw routing-profile-identifier* [id]
     |        +--rw id    string
     +--rw vpn-services
        ...                   ]]></artwork>
        </figure>

        <t></t>
      </section>

      <section anchor="vpn_service" title="VPN Services">
        <t>The 'vpn-service' is the data structure that abstracts a VPN
        service in the service provider network. Each 'vpn-service' is
        uniquely identified by an identifier: 'vpn-id'. Such 'vpn-id' is only
        meaningful locally within the network controller.</t>

        <t><figure align="center" anchor="vpn-service_tree"
            title="VPN Services Subtree Structure">
            <artwork align="center"><![CDATA[  +--rw l3vpn-ntw
     +--rw vpn-profiles
     |  ...
     +--rw vpn-services
        +--rw vpn-service* [vpn-id]
           +--rw vpn-id                   vpn-id
           +--rw vpn-name?                string
           +--rw vpn-description?         string
           +--rw customer-name?           string
           +--rw l3sm-vpn-id?             vpn-common:vpn-id
           +--rw vpn-type?                identityref
           +--rw vpn-service-topology?    identityref
           +--rw status
           |  +--rw admin-status
           |  |  +--rw status?         identityref
           |  |  +--rw last-updated?   yang:date-and-time
           |  +--rw oper-status
           |     +--ro status?         identityref
           |     +--ro last-updated?   yang:date-and-time
           +--rw ie-profiles
           |  ...
           +--rw underlay-transport
           |  +--rw type*   identityref
           +--rw external-connectivity
           |  +--rw (profile)?
           |     +--:(profile)
           |        +--rw profile-name?   leafref
           +--rw vpn-nodes
              ...
]]></artwork>
          </figure></t>

        <t>The 'vpn-service' data nodes listed in <xref
        target="vpn-service_tree"></xref> are as follows:<list style="hanging">
            <t hangText="'vpn-id':">Is an identifier that is used to uniquely
            identify the L3VPN service within L3NM scope.</t>

            <t hangText="'vpn-name' and 'vpn-description':">Are used to
            associate a name and a description with the service in order to
            facilitate the identification of the service.</t>

            <t hangText="'customer-name':">Indicates the name of the customer
            who ordered the service.</t>

            <t hangText="'l3sm-vpn-id':">Refers to an identifier of the L3SM
            service. This identifier allows to easily correlate the (network)
            service as built in the network with a service order.</t>

            <t hangText="'vpn-type':">Indicates the VPN type (L3VPN).</t>

            <t hangText="'vpn-service-topology':">Indicates the network
            topology for the service: hub-spoke, any-to-any, and custom. The
            network implementation of this attribute is defined by the correct
            usage of import and export profiles.</t>

            <t hangText="'status':">Allows the control of the operative and
            administrative status of the service as a whole. The L3NM allows
            to track service status ('status') of a given VPN service. Both
            operational and administrative status are maintained together with
            a timestamp. For example, a service can be created, but not put
            into effect.<vspace blankLines="1" />Administrative and
            operational status can be used as trigger to detect service
            anomalies. For example, a service that is declared at the service
            layer as active but still inactive at the network layer is an
            indication that network provision actions are needed to align the
            observed service with the expected service status.</t>

            <t hangText="'ie-profiles':">Defines reusable import/export
            policies for the same 'vpn-service'. <vspace blankLines="1" />More
            details are provided in <xref target="ie_profiles"></xref>.</t>

            <t hangText="'underlay-transport':">Describes the preference for
            the transport technology to carry the traffic of the VPN service.
            This preference is especially useful in networks with multiple
            domains and Network-to-Network Interface (NNI) types. This version
            of the YANG module supports these options: BGP, LDP, GRE, SR,
            SR-TE, and RSVP-TE as underlay transport mechanisms. Other
            profiles can be defined in the future.</t>

            <t hangText="'external-connectivity':">Indicates whether/how
            external connectivity is provided to the VPN service. Only a
            pointer to a local profile is supported in this version.</t>

            <t hangText="'vpn-node':">Is an abstraction that represents a set
            of policies applied to a network node and that belong to a single
            'vpn-service'. A VPN service is typically built by adding
            instances of 'vpn-node' to the 'vpn-nodes' container. <vspace
            blankLines="1" />A 'vpn-node' contains 'vpn-network-accesses',
            which are the interfaces attached to the VPN by which the customer
            traffic is received. Therefore, the customer sites are connected
            to the 'vpn-network-accesses'.<vspace blankLines="1" />Note that,
            as this is a network data model, the information about customers
            sites is not required in the model. Such information is rather
            relevant in the L3SM. <vspace blankLines="1" />More details are
            provided in <xref target="vpn_node"></xref>.</t>
          </list></t>

        <section anchor="ie_profiles"
                 title="Concept of Import/Export Profiles">
          <t>The import and export profiles construct contains a list with
          information related with route targets and distinguishers (RTs and
          RDs), grouped and identified by 'ie-profile-id'. The identifier is
          then referenced in one or multiple 'vpn-nodes' (<xref
          target="vpn_node"></xref>) so the controller can identify RTs and
          RDs to be configured for a given VRF. The subtree is shown in <xref
          target="ie"></xref>.</t>

          <t>Note that RDs can be explicitly configured or automatically
          assigned. RD auto-assignment can also constrained by indicating an
          'rd-pool-name'.</t>

          <t><figure align="center" anchor="ie"
              title="Subtree Structure of Import/Export Profiles">
              <artwork align="center"><![CDATA[  +--rw l3vpn-ntw
     +--rw vpn-profiles
     |  ...
     +--rw vpn-services
        +--rw vpn-service* [vpn-id]
           +--rw vpn-id                  vpn-common:vpn-id
           +  ...
           +--rw ie-profiles
           |  +--rw ie-profile* [ie-profile-id]
           |     +--rw ie-profile-id         string
           |     +--rw (rd-choice)?
           |     |  +--:(directly-assigned)
           |     |  |  +--rw rd?
           |     |  |          rt-types:route-distinguisher
           |     |  +--:(pool-assigned)
           |     |  |  +--rw rd-pool-name?   string
           |     |  |  +--ro rd-from-pool?
           |     |  |          rt-types:route-distinguisher
           |     |  +--:(full-autoasigned)
           |     |  |  +--rw auto?           empty
           |     |  |  +--ro rd-auto?
           |     |  |          rt-types:route-distinguisher
           |     |  +--:(no-rd)
           |     |     +--rw no-rd?          empty
           |     +--rw vpn-targets
           |        +--rw vpn-target* [id]
           |        |  +--rw id                   int8
           |        |  +--rw route-targets* [route-target]
           |        |  |  +--rw route-target    rt-types:route-target
           |        |  +--rw route-target-type
           |        |          rt-types:route-target-type
           |        +--rw vpn-policies
           |           +--rw import-policy?   string
           |           +--rw export-policy?   string
           +--rw vpn-nodes
              +--rw vpn-node* [ne-id]
                 +--rw ne-id                      string
                 ...
                 +--rw vpn-targets
                 |  +--rw vpn-target* [id]
                 |  |  +--rw id                   int8
                 |  |  +--rw route-targets* [route-target]
                 |  |  |  +--rw route-target    rt-types:route-target
                 |  |  +--rw route-target-type
                 |  |          rt-types:route-target-type
                 |  +--rw vpn-policies
                 |     +--rw import-policy?   string
                 |     +--rw export-policy?   string
                 ...
]]></artwork>
            </figure></t>
        </section>

        <section anchor="vpn_node" title="VPN Nodes">
          <t>The 'vpn-node' is an abstraction that represents a set of common
          policies applied on a given network node (tipcally, a PE) and belong
          to one L3VPN service. In order to indicate the network nodes where
          the 'vpn-node' applies, the 'ne-id' must be indicated. The
          'vpn-node' includes a parameter to indicate the network node on
          which it is applied. In the case that the 'ne-id' points to a
          specific PE, the 'vpn-node' will likely be mapped into a VRF in the
          node. However, the model also allows to point to an abstract node.
          In this case, the network controller will decide how to split the
          'vpn-node' into VRFs. Some 'vpn-node' parameters are listed
          below:<list style="hanging">
              <t hangText="'vpn-node-id':"></t>

              <t hangText="'xxxx':"></t>

              <t hangText="'local-autonomous-system':">Refers to the
              autonomous system number that is locally configured in the
              instance. It can be overwritten for specific purposes in the
              CE-PE BGP session.</t>

              <t hangText="'maximum-routes':">Sets the maximum number of
              prefixes allowed in the 'vpn-node' instance. This value is
              typically set in the service request.</t>

              <t hangText="'rd' and 'vpn-targets':">For the cases the logical
              resources are managed outside the network controller, the model
              allows to explicitely indicate the logical resources such as
              Route targets (RTs) and Route Distinguishers (RDs) (RT,RD).</t>

              <t hangText="'multicast':">Enables multicast traffic inside the
              VPN. Refer to <xref target="mc"></xref>.</t>
            </list></t>

          <t>Under the VPN Node ('vpn-node') container, VPN Network Accesses
          ('vpn-network-access') can be created. The VPN Network Access
          represents the point to which sites are connected. Note that, unlike
          in L3SM, the L3NM does not need to model the customer site, only the
          points where the traffic from the site are received (i.e., the PE
          side of PE-CE connections). Hence, the VPN Network access contains
          the connectivity information between the provider's network and the
          customer premises. The VPN profiles ('vpn-profiles') have a set of
          routing policies than can be applied during the service
          creation.</t>

          <t>The L3NM allows to track the status ('status') of the nodes
          involved in a VPN service. Both operational and administrative
          status are maintained. Mismatch between an administrative status vs.
          the operational status can be used as trigger to detect
          anomalies.</t>

          <figure align="center" anchor="vpn-node_tree"
                  title="VPN Node Subtree Structure">
            <artwork align="center"><![CDATA[  +--rw l3vpn-ntw
     +--rw vpn-profiles
     |  ...
     +--rw vpn-services
        +--rw vpn-service* [vpn-id]
           ...
           +--rw vpn-nodes
              +--rw vpn-node* [vpn-node-id]
                 +--rw vpn-node-id                union
                 +--rw description?               string
                 +--rw ne-id?                     string
                 +--rw node-role?                 identityref
                 +--rw local-autonomous-system?   inet:as-number
                 |       {vpn-common:rtg-bgp}?
                 +--rw address-family?            identityref
                 +--rw router-id?                 inet:ip-address
                 +--rw (rd-choice)?
                 |  +--:(directly-assigned)
                 |  |  +--rw rd?
                 |  |          rt-types:route-distinguisher
                 |  +--:(pool-assigned)
                 |  |  +--rw rd-pool-name?        string
                 |  |  +--ro rd-from-pool?
                 |  |          rt-types:route-distinguisher
                 |  +--:(full-autoasigned)
                 |  |  +--rw auto?                empty
                 |  |  +--ro rd-auto?
                 |  |          rt-types:route-distinguisher
                 |  +--:(no-rd)
                 |     +--rw no-rd?               empty
                 +--rw vpn-targets
                 |  +--rw vpn-target* [id]
                 |  |  +--rw id                   int8
                 |  |  +--rw route-targets* [route-target]
                 |  |  |  +--rw route-target    rt-types:route-target
                 |  |  +--rw route-target-type
                 |  |          rt-types:route-target-type
                 |  +--rw vpn-policies
                 |     +--rw import-policy?   string
                 |     +--rw export-policy?   string
                 +--rw node-ie-profile?           leafref
                 +--rw maximum-routes
                 |  +--rw address-family* [af]
                 |  |  +--rw af                identityref
                 |  |  +--rw maximum-routes?   uint32
                 |  +--rw status
                 |     +--rw admin-status
                 |     |  +--rw status?         identityref
                 |     |  +--rw last-updated?   yang:date-and-time
                 |     +--rw oper-status
                 |        +--ro status?         identityref
                 |        +--ro last-updated?   yang:date-and-time
                 +--rw groups
                 |  +--rw group* [group-id]
                 |     +--rw group-id    string
                 +--rw multicast {vpn-common:multicast}?
                 |  ...
                 +--rw vpn-network-accesses
                    ...]]></artwork>
          </figure>

          <section anchor="rt_rd_assignment" title="RT/RD Assignment">
            <t>For the cases the logical resources are managed outside the
            network controller, the model allows to explicitely indicate the
            logical resources such as Route targets (RTs) and Route
            Distinguishers (RDs) (RT,RD).</t>

            <t>Three possible behaviors are needed to fulfil the identified
            use cases: <list style="symbols">
                <t>The network controller auto-assigns logical resources (RTs,
                RDs). This can apply for new services deployment.</t>

                <t>The Network Operator/service orchestrator assigns
                explicitly the RTs and RDs. This case will fit with a
                brownfield scenario where some existing services needs to be
                updated by the network operators.</t>

                <t>The Network Operator/Service orchestrator explicitly 
                  wants NO RT/ RD to be assigned.  This case will fit in 
                  VRF-Lite scenarios, CE testing inside the Network, or 
                  just for troubleshooting purposes.</t>
              </list></t>

            <t>Thus a union between two yang data types are included in order
            to support this scenarios. So, if the leaf is not created in the
            Yang the expected behavior is the auto-assigns. If the Leaf is
            created with a valid rd value it will be explicitly assign in the
            VPN Node and if the leaf is created with an empty value, the RD
            value will not be deployed in the VPN node.</t>
          </section>

          <section anchor="mc" title="Multicast">
            <t>Multicast may be enabled for a particular vpn-network-node (see
            <xref target="multicast"></xref>).</t>

            <t>The model supports a single type of tree (Any-Source Multicast
            (ASM), Source-Specific Multicast (SSM), or bidirectional).</t>

            <t>When ASM is used, the model supports the configuration of
            rendez-vous points (RPs). RP discovery may be 'static', 'bsr-rp',
            or 'auto-rp'. When set to 'static', RP to multicast grouping
            mapping MUST be configured as part of the 'rp-group-mappings'
            container. The RP MAY be a provider node or a customer node. When
            the RP is a customer node, the RP address must be configured using
            the 'rp-address' leaf otherwise no RP address is needed.</t>

            <t>The model supports RP redundancy through the 'rp-redundancy'
            leaf. How the redundancy is achieved is out of scope and is up to
            the implementation.</t>

            <t>When a particular VPN using ASM requires a more optimal traffic
            delivery, 'optimal-traffic-delivery' can be set. When set to
            'true', the implementation must use any mechanism to provide a
            more optimal traffic delivery for the customer. Anycast is one of
            the mechanisms to enhance RPs redundancy, resilience against
            failures, and to recover from failures quickly.</t>

            <t>For redundancy purposes, Multicast Source Discovery Protocol
            (MSDP) <xref target="RFC3618"></xref> may be enabled and used to
            share the state about sources between multiple RPs. The purpose of
            MSDP in this context is to enhance the robustness of the multicast
            service. MSDP may be configured on Non-RP routers, which is useful
            in a domain that does not support multicast sources, but does
            support multicast transit.</t>

            <t><figure align="center" anchor="multicast"
                title="Multicast Subtree Structure">
                <artwork align="center"><![CDATA[           +--rw vpn-nodes
              +--rw vpn-node* [vpn-node-id]
                 ...
                 +--rw multicast {vpn-common:multicast}?
                 |  +--rw enabled?       boolean
                 |  +--rw tree-flavor*   identityref
                 |  +--rw rp
                 |  |  +--rw rp-group-mappings
                 |  |  |  +--rw rp-group-mapping* [id]
                 |  |  |     +--rw id                  uint16
                 |  |  |     +--rw provider-managed
                 |  |  |     |  +--rw enabled?
                 |  |  |     |  |       boolean
                 |  |  |     |  +--rw rp-redundancy?
                 |  |  |     |  |       boolean
                 |  |  |     |  +--rw optimal-traffic-delivery?
                 |  |  |     |  |       boolean
                 |  |  |     |  +--rw anycast
                 |  |  |     |     +--rw local-address?
                 |  |  |     |     |       inet:ip-address
                 |  |  |     |     +--rw rp-set-address*
                 |  |  |     |             inet:ip-address
                 |  |  |     +--rw rp-address
                 |  |  |     |       inet:ip-address
                 |  |  |     +--rw groups
                 |  |  |        +--rw group* [id]
                 |  |  |           +--rw id
                 |  |  |           |       uint16
                 |  |  |           +--rw (group-format)
                 |  |  |              +--:(group-prefix)
                 |  |  |              |  +--rw group-address?
                 |  |  |              |          inet:ip-prefix
                 |  |  |              +--:(startend)
                 |  |  |                 +--rw group-start?
                 |  |  |                 |       inet:ip-address
                 |  |  |                 +--rw group-end?
                 |  |  |                         inet:ip-address
                 |  |  +--rw rp-discovery
                 |  |     +--rw rp-discovery-type?   identityref
                 |  |     +--rw bsr-candidates
                 |  |        +--rw bsr-candidate-address*
                 |  |                inet:ip-address
                 |  +--rw msdp {msdp}?
                 |     +--rw enabled?         boolean
                 |     +--rw peer?            inet:ip-address
                 |     +--rw local-address?   inet:ip-address
                 +--rw vpn-network-accesses
                    ...]]></artwork>
              </figure></t>

            <t></t>
          </section>

          <section anchor="sna" title="VPN Network Access">
            <t>A 'vpn-network-access' represents an entry point to a VPN
            service (<xref target="vpnaccess"></xref>). In other words, this
            container encloses the parameters that describe the access
            information for the traffic that belongs to a particular L3VPN. As
            such, every 'vpn-network-access' MUST belong to one and only one
            'vpn-node'.</t>

            <t>A 'vpn-network-access' includes information such as the
            connection on which the access is defined (see <xref
            target="connection"></xref>), the encapsulation of the traffic,
            policies that are applied on the access, etc.</t>

            <t>Each 'vpn-network-access' SHOULD have a
            'vpn-network-access-type' to select the type of network interface
            to be deployed in the devices. The available options are: <list
                style="symbols">
                <t>Point-to-Point: The point-to-point type represent a direct
                connection between the end-points. It implies the controller
                must keep the association between a logical or physical
                interface on the device with the 'id' of the
                vpn-network-access.</t>

                <t>Multipoint: This option represents a broadcast connection
                between end-points. It implies the controller must keep the
                association between a logical or physical interface on the
                device with the 'id' of the 'vpn-network-access'.</t>

                <t>Pseudowire: Represent a connection coming from an L2VPN
                service. It implies the controller must keep the relationship
                between the logical tunnels or bridges on the devices with the
                'id' of the' vpn-network-access'.</t>

                <t>Loopback: It represents the creation of a logical interface
                on the devices.</t>
              </list></t>

            <t>A PNC <xref target="RFC8453"></xref> will accept VPN requests
            containing this construct, using the enclosed data to: configure
            the router's interface to include the parameters described at the
            'vpn-network-access', include the given interface into a VRF,
            configuring policies or schedulers for processing the incoming
            traffic, etc.</t>

            <t><figure align="center" anchor="vpnaccess"
                title="VPN Network Access Tree Structure">
                <artwork align="left"><![CDATA[ ...
 +--rw vpn-services
    +--rw vpn-service* [vpn-id]
       +--rw vpn-id                  vpn-common:vpn-id
       +  ...
        +--rw vpn-node* [ne-id]
           +--rw ne-id                      string
           + ...
           +--rw vpn-network-accesses
           |  +--rw vpn-network-access* [id]
           |     +--rw id
           |     |       vpn-common:vpn-id
           |     +--rw port-id?
           |     |       vpn-common:vpn-id
           |     +--rw description?               string
           |     +--rw status
           |     |  +--rw admin-enabled?   boolean
           |     |  +--ro oper-status?     operational-type
           |     +--rw vpn-network-access-type?   identityref
           |     +--rw connection
           |     |  ...
           |     +--rw ip-connection
           |     |  ...
           |     +--rw security
           |     |  ...
           |     +--rw routing-protocols
           |     |  ...
           |     +--rw service
           |        ...
           ...    ]]></artwork>
              </figure></t>

            <section anchor="connection" title="Connection">
              <t>The definition of a L3VPN is commonly specified not only at
              the IP layer, but also requires to identify parameters at the
              Ethernet layer, such as encapsulation type (e.g., VLAN, QinQ,
              QinAny, VxLAN, etc.). The 'connection' container represents and
              groups the set of Layer 2 connectivity from where the traffic of
              the L3VPN in a particular VPN Network access is coming.</t>

              <t>Ethernet encapsulation description is not supported in <xref
              target="RFC8299"></xref>. However, this parameters are mandatory
              to configure the PE interfaces. Thus, in the L3NM, these
              parameters uses the connection container inside the
              'vpn-network-access'. This container defines protocols and
              parameters to enable connectivity at Layer 2.</t>

              <figure align="center" anchor="bearerethencap_tree"
                      title="Encapsulation Subtree Structure">
                <artwork align="left"><![CDATA[ ...
 +--rw vpn-services
    +--rw vpn-service* [vpn-id]
       +--rw vpn-id                  vpn-common:vpn-id
       +  ...
        +--rw vpn-node* [ne-id]
           +--rw ne-id                      string
           + ...          
           +--rw vpn-network-accesses
           |  +--rw vpn-network-access* [id]
           |     +--rw id
           |     |       vpn-common:vpn-id
           |     ...
           |     +--rw connection
           |     |  +--rw encapsulation-type?   identityref
           |     |  +--rw logical-interface
           |     |  |  +--rw peer-reference?   uint32
           |     |  +--rw tagged-interface
           |     |  |  +--rw type?                identityref
           |     |  |  +--rw dot1q-vlan-tagged
           |     |  |  |       {vpn-common:dot1q}?
           |     |  |  |  +--rw tag-type?   identityref
           |     |  |  |  +--rw cvlan-id?   uint16
           |     |  |  +--rw priority-tagged
           |     |  |  |  +--rw tag-type?   identityref
           |     |  |  +--rw qinq {vpn-common:qinq}?
           |     |  |  |  +--rw tag-type?   identityref
           |     |  |  |  +--rw svlan-id    uint16
           |     |  |  |  +--rw cvlan-id    uint16
           |     |  |  +--rw qinany {vpn-common:qinany}?
           |     |  |  |  +--rw tag-type?   identityref
           |     |  |  |  +--rw svlan-id    uint16
           |     |  |  +--rw vxlan {vpn-common:vxlan}?
           |     |  |     +--rw vni-id       uint32
           |     |  |     +--rw peer-mode?   identityref
           |     |  |     +--rw peer-list* [peer-ip]
           |     |  |        +--rw peer-ip    inet:ip-address
           |     |  +--rw bearer
           |     |     ...
           ...              ]]></artwork>
              </figure>

              <t></t>

              <t>Additionally, the 'bearer-reference' and the pseudowire
              termination are supported (see <xref
              target="rfeconfiguration_tree"></xref>). A site, as per <xref
              target="RFC4176"></xref> represents a VPN customer's location
              that is connected to the service provider network via a CE-PE
              link, which can access at least one VPN. The connection from the
              site to the service provider network is the bearer. Every site
              is associated with a list of bearers. A bearer is the layer two
              connections with the site. In the module it is assumed that the
              bearer has been allocated by the service provider at the service
              orchestration step. The bearer is associated to a network
              element and a port. Hence, a bearer is just a bearer-reference
              to allow the translation between L3SM and L3NM.</t>

              <figure align="center" anchor="rfeconfiguration_tree"
                      title="Bearer Subtree Structure">
                <artwork align="left"><![CDATA[...
+--rw vpn-network-accesses
|  +--rw vpn-network-access* [id]
|     +--rw id
|     |       vpn-common:vpn-id
|     ...
|     +--rw vpn-network-access-type?   identityref
|     +--rw connection
|     |  ...
|     |  +--rw bearer
|     |     +--rw bearer-reference?   string
|     |     |       {vpn-common:bearer-reference}?
|     |     +--rw pseudowire
|     |     |  +--rw vcid?      uint32
|     |     |  +--rw far-end?   union
|     |     +--rw vpls
|     |        +--rw vcid?      union
|     |        +--rw far-end?   union
|  ...            ]]></artwork>
              </figure>

              <t></t>

              <t></t>
            </section>

            <section anchor="ip_conn" title="IP Connections">
              <t>IP connection container (<xref target="ip_conn_tree"></xref>)
              has the parameters of the 'vpn-network-access' addressing
              information. The address allocated in this container would
              represent the PE interface address configuration. The IP
              connection container is designed to support both IPv4 and IPv6.
              It also supports three IP address assignment modes: SLAAC <xref
              target="RFC7527"></xref>, Provider DHCP, DHCP relay, and static
              addressing. Only one of them is enabled for a given service.<!--Med: Check if slaac need to be mentionned--></t>

              <t><figure align="center" anchor="ip_conn_tree"
                  title="IP Connection Subtree Structure">
                  <artwork align="center"><![CDATA[...
+--rw vpn-network-accesses
|  +--rw vpn-network-access* [id]
|     +--rw id
|     |       vpn-common:vpn-id
|     ...
|     +--rw vpn-network-access-type?   identityref
|     +--rw connection
|     |  ...
|     +--rw ip-connection
|     |  +--rw ipv4 {vpn-common:ipv4}?
|     |  |  +--rw address-allocation-type?
|     |  |  |       identityref
|     |  |  +--rw (allocation-type)?
|     |  |     +--:(provider-dhcp)
|     |  |     |  +--rw provider-address?
|     |  |     |  |       inet:ipv4-address
|     |  |     |  +--rw prefix-length?
|     |  |     |  |       uint8
|     |  |     |  +--rw (address-assign)?
|     |  |     |     +--:(number)
|     |  |     |     |  +--rw number-of-dynamic-address?
|     |  |     |     |          uint16
|     |  |     |     +--:(explicit)
|     |  |     |        +--rw customer-addresses
|     |  |     |           +--rw address-group*
|     |  |     |                   [group-id]
|     |  |     |              +--rw group-id
|     |  |     |              |       string
|     |  |     |              +--rw start-address?
|     |  |     |              |       inet:ipv4-address
|     |  |     |              +--rw end-address?
|     |  |     |                      inet:ipv4-address
|     |  |     +--:(dhcp-relay)
|     |  |     |  +--rw dr-provider-address?
|     |  |     |  |       inet:ipv4-address
|     |  |     |  +--rw dr-prefix-length?
|     |  |     |  |       uint8
|     |  |     |  +--rw customer-dhcp-servers
|     |  |     |     +--rw server-ip-address*
|     |  |     |             inet:ipv4-address
|     |  |     +--:(static-addresses)
|     |  |        ...
|     |  +--rw ipv6 {vpn-common:ipv6}?
|     |  |  +--rw address-allocation-type?
|     |  |  |       identityref
|     |  |  +--rw (allocation-type)?
|     |  |     +--:(provider-dhcp)
|     |  |     |  +--rw (provider-dhcp)?
|     |  |     |     +--:(provider-address)
|     |  |     |     |  +--rw provider-address?
|     |  |     |     |          inet:ipv6-address
|     |  |     |     +--:(prefix-length)
|     |  |     |     |  +--rw prefix-length?
|     |  |     |     |          uint8
|     |  |     |     +--:(address-assign)
|     |  |     |        +--rw (address-assign)?
|     |  |     |           +--:(number)
|     |  |     |           |  +--rw number-of-dynamic-address?
|     |  |     |           |          uint16
|     |  |     |           +--:(explicit)
|     |  |     |              +--rw customer-addresses
|     |  |     |                 +--rw address-group*
|     |  |     |                         [group-id]
|     |  |     |                    +--rw group-id
|     |  |     |                    |       string
|     |  |     |                    +--rw start-address?
|     |  |     |                    |       inet:ipv6-address
|     |  |     |                    +--rw end-address?
|     |  |     |                            inet:ipv6-address
|     |  |     +--:(dhcp-relay)
|     |  |     |  +--rw dr-provider-address?
|     |  |     |  |       inet:ipv6-address
|     |  |     |  +--rw dr-prefix-length?
|     |  |     |  |       uint8
|     |  |     |  +--rw customer-dhcp-servers
|     |  |     |     +--rw server-ip-address*
|     |  |     |             inet:ipv6-address
|     |  |     +--:(static-addresses)
|     |  |        ...]]></artwork>
                </figure></t>

              <t>In the case of the static addressing (<xref
              target="ip_conn_tree-static"></xref>), the model supports the
              assignment of several IP addresses in the same
              'vpn-network-access'. To identify which of the addresses is the
              primary address of a connection ,the 'primary-address' reference
              MUST be set with the corresponding 'address-id'.</t>

              <figure align="center" anchor="ip_conn_tree-static"
                      title="IP Connection Subtree Structure: Static Mode">
                <artwork align="left"><![CDATA[           ...
           +--rw vpn-network-accesses
              |  +--rw vpn-network-access* [id]
              |     +--rw id
              |     |       vpn-common:vpn-id
              |     ...
              |     +--rw vpn-network-access-type?   identityref
              |     +--rw connection
              |     |  ...
              |     +--rw ip-connection
              |     |  +--rw ipv4 {vpn-common:ipv4}?
              |     |  |  +--rw address-allocation-type?
              |     |  |  |       identityref
              |     |  |  +--rw (allocation-type)?
              |     |  |     ...
              |     |  |     +--:(static-addresses)
              |     |  |        +--rw primary-address?
              |     |  |        |       -> ../address/address-id
              |     |  |        +--rw address* [address-id]
              |     |  |           +--rw address-id
              |     |  |           |       string
              |     |  |           +--rw s-provider-address?
              |     |  |           |       inet:ipv4-address
              |     |  |           +--rw s-customer-address?
              |     |  |           |       inet:ipv4-address
              |     |  |           +--rw s-prefix-length?
              |     |  |                   uint8
              |     |  +--rw ipv6 {vpn-common:ipv6}?
              |     |  |  +--rw address-allocation-type?
              |     |  |  |       identityref
              |     |  |  +--rw (allocation-type)?
              |     |  |     ...
              |     |  |     +--:(static-addresses)
              |     |  |        +--rw s-primary-address?
              |     |  |        |       -> ../s-address/address-id
              |     |  |        +--rw s-address* [address-id]
              |     |  |           +--rw address-id
              |     |  |           |       string
              |     |  |           +--rw provider-address?
              |     |  |           |       inet:ipv6-address
              |     |  |           +--rw customer-address?
              |     |  |           |       inet:ipv6-address
              |     |  |           +--rw prefix-length?      uint8
              ...                        ]]></artwork>
              </figure>
            </section>

            <section anchor="ro_pro" title="CE-PE Routing Protocols">
              <t>A service provider can configure one or more routing
              protocols associated with a particular 'vpn-network-access'
              (<xref target="routing"></xref>). Such routing protocol is
              enabled between the PE and the CE. Each instance is uniquely
              identified to accommodate scenarios where multiple instances of
              the same routing protocol have to be configured.</t>

              <t><figure align="center" anchor="routing"
                  title="Routing Subtree Structure">
                  <artwork align="center"><![CDATA[  ...
  +--rw vpn-network-accesses
     +--rw vpn-network-access* [id]
        ...  
        +--rw routing-protocols
        |  +--rw routing-protocol* [id]
        |     +--rw id   string
        |     +--rw type?               identityref
        |     +--rw routing-profiles* [id]
        |     |  +--rw id      leafref
        |     |  +--rw type?   identityref
        |     +--rw static
        |     |  ...
        |     +--rw bgp {vpn-common:rtg-bgp}?
        |     |  ...
        |     +--rw ospf {vpn-common:rtg-ospf}?
        |     |  ...
        |     +--rw isis {vpn-common:rtg-isis}?
        |     |  ...
        |     +--rw rip {vpn-common:rtg-rip}?
        |     |  ...
        |     +--rw vrrp {vpn-common:rtg-vrrp}?
        |        ...
        +--rw security
            ...
]]></artwork>
                </figure></t>

              <t>Routing configuration does not include low-level policies.
              Such policies are handed at the device configuration level.
              Local policies of a service provider (e.g., filtering) will be
              implemented as part of the device configuration; these are not
              captured in the L3NM but the model allows to associate local
              profiles with routing instances. </t>

              <t>Configuring multiple instances of the same routing protocol
              does not automatically imply that, from a device configuration
              perspective, there will be parallel instances (e.g., multiple
              processes) running on the PE-CE link. It is up to each
              implementation to decide about the appropriate configuration as
              a function of underlying capabilities and service provider
              operational guidelines. As an example, when multiple BGP peers
              need to be implemented, multiple instances of BGP must be
              configured as part of this model. However, from a device
              configuration point of view, this could be implemented as: <list
                  style="symbols">
                  <t>Multiple BGP processes with a single neighbor running in
                  each process.</t>

                  <t>A single BGP process with multiple neighbors running.</t>

                  <t>A combination of both.</t>
                </list></t>

              <t>The L3NM supports the configuration of one or more IPv4/IPv6
              static routes. Since the same structure is used for both IPv4
              and IPv6, it was considered to have one single container to
              group both static entries independently of their address family,
              but hat design was abandoned to ease the mapping with the
              structure in <xref target="RFC8299"></xref>. As depicted in
              <xref target="routing-static"></xref>, the following attributes
              can be defined for a given IP prefix:<list style="hanging">
                  <t hangText="'lan-tag':">Indicates a local tag (e.g.,
                  my_favourite-lan) that is used to enforce local policies.
                  </t>

                  <t hangText="'next-hop':">Indicates the next-hop to be used
                  for the static route. It can be identified by an IP address,
                  an interface, etc. </t>

                  <t hangText="'bfd-enable':">Indicates whether BFD is enabled
                  or disabled for this entry.</t>

                  <t hangText="'metric':">Indicates the metric associated with
                  the static routing entry.</t>

                  <t hangText="'preference':">Indicates the preference
                  associated with the static routing entry.</t>
                </list></t>

              <t><figure align="center" anchor="routing-static"
                  title="Static Routing Subtree Structure">
                  <artwork align="center"><![CDATA[  ...
  +--rw vpn-network-accesses
     +--rw vpn-network-access* [id]
        ...  
        +--rw routing-protocols
        |  +--rw routing-protocol* [id]
        |     +--rw id   string
        |     +--rw type?               identityref
        |     +--rw routing-profiles* [id]
        |     |  +--rw id      leafref
        |     |  +--rw type?   identityref
        |     +--rw static
        |     |  +--rw cascaded-lan-prefixes
        |     |     +--rw ipv4-lan-prefixes*
        |     |     |       [lan next-hop]
        |     |     |       {vpn-common:ipv4}?
        |     |     |  +--rw lan
        |     |     |  |       inet:ipv4-prefix
        |     |     |  +--rw lan-tag?    string
        |     |     |  +--rw next-hop      union
        |     |     |  +--rw bfd-enable?   boolean
        |     |     |  +--rw metric?       uint32
        |     |     |  +--rw preference?   uint32
        |     |     +--rw ipv6-lan-prefixes*
        |     |             [lan next-hop]
        |     |             {vpn-common:ipv6}?
        |     |        +--rw lan
        |     |        |       inet:ipv6-prefix
        |     |        +--rw lan-tag?    string
        |     |        +--rw next-hop      union
        |     |        +--rw bfd-enable?   boolean
        |     |        +--rw metric?       uint32
        |     |        +--rw preference?   uint32 
        |     +--rw bgp {vpn-common:rtg-bgp}?
        |     |  ...
        |     +--rw ospf {vpn-common:rtg-ospf}?
        |     |  ...
        |     +--rw isis {vpn-common:rtg-isis}?
        |     |  ...
        |     +--rw rip {vpn-common:rtg-rip}?
        |     |  ...
        |     +--rw vrrp {vpn-common:rtg-vrrp}?
        |        ...
        +--rw security
           ...
]]></artwork>
                </figure></t>

              <t>In addition, this L3Nm supports the following CE-PE routing
              protocols: <list style="hanging">
                  <t hangText="BGP:">The model (<xref
                  target="routing-bgp"></xref>) allows to configure a BGP
                  neighbor, including a set for parameters that are pertinent
                  to be tweaked at the network level for service customization
                  purposes. This container does not aim to include every BGP
                  parameter; a comprehensive set of parameters belongs more to
                  the BGP device model. The following parameters are captured
                  in <xref target="routing-bgp"></xref>. It is up to the
                  implementation to drive the corresponding BGP device
                  configuration.<list style="symbols">
                      <t>'peer-autonomous-system': This parameter conveys the
                      Customer's AS Number (ASN).</t>

                      <t>'local-autonomous-system': This parameter is set of
                      AS override is activated for this peer.</t>

                      <t>'address-family': This attribute indicates the
                      address-family of the peer. It can be set to IPv4, IPv6,
                      or both address-families.</t>

                      <t>'neighbor': The module supports supplying two
                      neighbors (each for a given address-family) or one
                      neighbor (if 'address-family' attribute is set to both
                      IPv4 and IPv6 address-families). A list of IP
                      address(es) of the BGP neighbor can be then conveyed in
                      this parameter.</t>

                      <t>'multihop': This attribute indicates the number of
                      allowed IP hops between a BGP peer and a PE.</t>

                      <t>'security': The authentication type will be driven by
                      the implementation but the module supports any
                      authentication that uses a key as a parameter.</t>

                      <t>'as-override': If set, this parameter indicates
                      whether AS override is enabled, i.e., replace the ASN of
                      the peer specified in the AS Path attribute with the ASN
                      identified by the 'local-autonomous-system'
                      attribute.</t>

                      <t>'default-route': This attribute controls whether
                      default route(s) can be advertised to the peer.</t>

                      <t>'bgp-max-prefix': This attribute is used to control
                      how many prefixes can be received from a neighbor. If
                      reached, the BGP session will be teared down.</t>

                      <t>'bgp-timer': Two timers can be captured in this
                      container: (1) 'hold-time' which is the time interval
                      that will be used for the HoldTimer (Section 4.2 of
                      <xref target="RFC4271"></xref>) when establishing a BGP
                      session. (2) 'keep-alive' which is the time interval for
                      the KeepAlive timer between a PE and a BGP peer (Section
                      4.4 of <xref target="RFC4271"></xref>).</t>
                    </list><figure align="center" anchor="routing-bgp"
                      title="BGP Routing Subtree Structure">
                      <artwork align="center"><![CDATA[  ...
  +--rw vpn-network-accesses
     +--rw vpn-network-access* [id]
        ...  
        +--rw routing-protocols
        |  +--rw routing-protocol* [id]
        |     +--rw id   string
        |     +--rw type?               identityref
        |     +--rw routing-profiles* [id]
        |     |  +--rw id      leafref
        |     |  +--rw type?   identityref
        |     +--rw static
        |     |  ...
        |     +--rw bgp {vpn-common:rtg-bgp}?
        |     |  +--rw description?       string
        |     |  +--rw local-autonomous-system?
        |     |  |       inet:as-number
        |     |  +--rw peer-autonomous-system
        |     |  |       inet:as-number
        |     |  +--rw address-family*  identityref
        |     |  +--rw neighbor*     inet:ip-address
        |     |  +--rw multihop?         uint8
        |     |  +--rw as-override?      boolean
        |     |  +--rw default-route?    boolean
        |     |  +--rw bgp-max-prefix
        |     |  |  +--rw max-prefix?          uint32
        |     |  |  +--rw warning-threshold?  
        |     |  |  |       decimal64
        |     |  |  +--rw violate-action? 
        |     |  |  |       enumeration
        |     |  |  +--rw restart-interval?    uint16
        |     |  +--rw bgp-timer
        |     |  |  +--rw keep-alive?   uint16
        |     |  |  +--rw hold-time?    uint16
        |     |  +--rw security
        |     |  |  +--rw enable?            boolean
        |     |  |  +--rw keying-material
        |     |  |     +--rw (option)?
        |     |  |        +--:(md5)
        |     |  |        |  +--rw md5-keychain?
        |     |  |        |          kc:key-chain-ref
        |     |  |        +--:(ipsec)
        |     |  |           +--rw sa?   string
        |     |  +--rw status
        |     |     +--rw admin-status
        |     |     |  +--rw status?   identityref
        |     |     |  +--rw last-updated?
        |     |     |          yang:date-and-time
        |     |     +--rw oper-status
        |     |        +--ro status?  identityref
        |     |        +--ro last-updated?
        |     |                yang:date-and-time
        |     +--rw ospf {vpn-common:rtg-ospf}?
        |     |  ...
        |     +--rw isis {vpn-common:rtg-isis}?
        |     |  ...
        |     +--rw rip {vpn-common:rtg-rip}?
        |     |  ...
        |     +--rw vrrp {vpn-common:rtg-vrrp}?
        |        ...
        +--rw security
            ...
]]></artwork>
                    </figure></t>

                  <t hangText="OSPF:">The model (<xref
                  target="routing-ospf"></xref>) allows the user to configure
                  OSPF to run as routing protocol on the 'vpn-network-access
                  interface'. An OSPF instance can be bound to IPv4, IPv6 or
                  both. When only IPv4 address-family is requested, it will be
                  up to the implementation to drive whether OSPFv2 or OSPFv3
                  is used.<figure align="center" anchor="routing-ospf"
                      title="OPSF Routing Subtree Structure">
                      <artwork align="center"><![CDATA[  ...
  +--rw vpn-network-accesses
     +--rw vpn-network-access* [id]
        ...  
        +--rw routing-protocols
        |  +--rw routing-protocol* [id]
        |     +--rw id   string
        |     +--rw type?               identityref
        |     +--rw routing-profiles* [id]
        |     |  +--rw id      leafref
        |     |  +--rw type?   identityref
        |     +--rw static
        |     |  ...
        |     +--rw bgp {vpn-common:rtg-bgp}?
        |     |  ...
        |     +--rw ospf {vpn-common:rtg-ospf}?
        |     |  +--rw address-family*   identityref
        |     |  +--rw area-address
        |     |  |       yang:dotted-quad
        |     |  +--rw metric?           uint16
        |     |  +--rw mtu?              uint16
        |     |  +--rw process-id?       uint16
        |     |  +--rw sham-links
        |     |  |       {vpn-common:rtg-ospf-sham-link}?
        |     |  |  +--rw sham-link* [target-site]
        |     |  |     +--rw target-site
        |     |  |     |       vpn-common:vpn-id
        |     |  |     +--rw metric?        uint16
        |     |  +--rw security
        |     |  |  +--rw enable?            boolean
        |     |  |  +--rw keying-material
        |     |  |     +--rw (option)?
        |     |  |        +--:(md5)
        |     |  |        |  +--rw md5-keychain?
        |     |  |        |          kc:key-chain-ref
        |     |  |        +--:(ipsec)
        |     |  |           +--rw sa?  string
        |     |  +--rw status
        |     |     +--rw admin-status
        |     |     |  +--rw status?
        |     |     |  |       identityref
        |     |     |  +--rw last-updated?
        |     |     |          yang:date-and-time
        |     |     +--rw oper-status
        |     |        +--ro status?
        |     |        |       identityref
        |     |        +--ro last-updated?
        |     |                yang:date-and-time
        |     +--rw isis {vpn-common:rtg-isis}?
        |     |  ...
        |     +--rw rip {vpn-common:rtg-rip}?
        |     |  ...
        |     +--rw vrrp {vpn-common:rtg-vrrp}?
        |        ...
        +--rw security
            ...
]]></artwork>
                    </figure></t>

                  <t hangText="IS-IS:">The model (<xref
                  target="routing-isis"></xref>) allows the user to configure
                  IS-IS to run on the 'vpn-network-access' interface. An IS-IS
                  instance can run L1, L2, or both levels.<figure
                      align="center" anchor="routing-isis"
                      title="IS-IS Routing Subtree Structure">
                      <artwork align="center"><![CDATA[  ...
  +--rw vpn-network-accesses
     +--rw vpn-network-access* [id]
        ...  
        +--rw routing-protocols
        |  +--rw routing-protocol* [id]
        |     +--rw id   string
        |     +--rw type?               identityref
        |     +--rw routing-profiles* [id]
        |     |  +--rw id      leafref
        |     |  +--rw type?   identityref
        |     +--rw static
        |     |  ...
        |     +--rw bgp {vpn-common:rtg-bgp}?
        |     |  ...
        |     +--rw ospf {vpn-common:rtg-ospf}?
        |     |  ...
        |     +--rw isis {vpn-common:rtg-isis}?
        |     |  +--rw address-family*   identityref
        |     |  +--rw area-address
        |     |  |       yang:dotted-quad
        |     |  +--rw level?            identityref
        |     |  +--rw metric?           uint16
        |     |  +--rw process-id?       uint16
        |     |  +--rw mode?             enumeration
        |     |  +--rw status
        |     |     +--rw admin-status
        |     |     |  +--rw status?
        |     |     |  |       identityref
        |     |     |  +--rw last-updated?
        |     |     |          yang:date-and-time
        |     |     +--rw oper-status
        |     |        +--ro status?
        |     |        |       identityref
        |     |        +--ro last-updated?
        |     |                yang:date-and-time
        |     +--rw rip {vpn-common:rtg-rip}?
        |     |  ...
        |     +--rw vrrp {vpn-common:rtg-vrrp}?
        |        ...
        +--rw security
            ...
]]></artwork>
                    </figure></t>

                  <t hangText="RIP:">The module covers only a list of
                  address-family as parameter.<figure align="center"
                      anchor="rip" title="RIP Subtree Structure">
                      <artwork align="center"><![CDATA[  ...
  +--rw vpn-network-accesses
     +--rw vpn-network-access* [id]
        ...  
        +--rw routing-protocols
        |  +--rw routing-protocol* [id]
        |     +--rw id   string
        |     +--rw type?               identityref
        |     +--rw routing-profiles* [id]
        |     |  +--rw id      leafref
        |     |  +--rw type?   identityref
        |     +--rw static
        |     |  ...
        |     +--rw bgp {vpn-common:rtg-bgp}?
        |     |  ...
        |     +--rw ospf {vpn-common:rtg-ospf}?
        |     |  ...
        |     +--rw isis {vpn-common:rtg-isis}?
        |     |  ...
        |     +--rw rip {vpn-common:rtg-rip}?
        |     |  +--rw address-family*   identityref
        |     |  +--rw status
        |     |     +--rw admin-status
        |     |     |  +--rw status?
        |     |     |  |       identityref
        |     |     |  +--rw last-updated?
        |     |     |          yang:date-and-time
        |     |     +--rw oper-status
        |     |        +--ro status?
        |     |        |       identityref
        |     |        +--ro last-updated?
        |     |                yang:date-and-time
        |     +--rw vrrp {vpn-common:rtg-vrrp}?
        |        ...
        +--rw security
            ...
]]></artwork>
                    </figure></t>

                  <t hangText="VRRP:">The module covers only a list of
                  address-family as parameter.<figure align="center"
                      anchor="vrrp" title="VRRP Subtree Structure">
                      <artwork align="center"><![CDATA[  ...
  +--rw vpn-network-accesses
     +--rw vpn-network-access* [id]
        ...  
        +--rw routing-protocols
        |  +--rw routing-protocol* [id]
        |     +--rw id   string
        |     +--rw type?               identityref
        |     +--rw routing-profiles* [id]
        |     |  +--rw id      leafref
        |     |  +--rw type?   identityref
        |     +--rw static
        |     |  ...
        |     +--rw bgp {vpn-common:rtg-bgp}?
        |     |  ...
        |     +--rw ospf {vpn-common:rtg-ospf}?
        |     |  ...
        |     +--rw isis {vpn-common:rtg-isis}?
        |     |  ...
        |     +--rw rip {vpn-common:rtg-rip}?
        |     |  ...
        |     +--rw vrrp {vpn-common:rtg-vrrp}?
        |        +--rw address-family*   identityref
        |        +--rw vrrp-group?       uint8
        |        +--rw backup-peer?
        |        |       inet:ip-address
        |        +--rw priority?         uint8
        |        +--rw ping-reply?       boolean
        |        +--rw status
        |           +--rw admin-status
        |           |  +--rw status?
        |           |  |       identityref
        |           |  +--rw last-updated?
        |           |          yang:date-and-time
        |           +--rw oper-status
        |              +--ro status?
        |              |       identityref
        |              +--ro last-updated?
        |                      yang:date-and-time
        +--rw security
            ...
]]></artwork>
                    </figure></t>
                </list></t>

              <!--  (NOTE FOR EDITORS: it seems that the access-priority has been removed. We need to have one may be slightly different from L3SM) -->
            </section>

            <section title="Security">
              <t>The 'security' container specifies the authentication and the
              encryption to be applied for a given VPN network access (<xref
              target="security"></xref>).</t>

              <t><figure align="center" anchor="security"
                  title="Security Subtree Structure">
                  <artwork align="left"><![CDATA[     ...
     +--rw vpn-services
        +--rw vpn-service* [vpn-id]
           ...
           +--rw vpn-nodes
              +--rw vpn-node* [vpn-node-id]
                 ...
                 +--rw vpn-network-accesses
                    +--rw vpn-network-access* [id]
                       ...
                       +--rw security
                       |  +--rw encryption {vpn-common:encryption}?
                       |  |  +--rw enabled?   boolean
                       |  |  +--rw layer?     enumeration
                       |  +--rw encryption-profile
                       |     +--rw (profile)?
                       |        +--:(provider-profile)
                       |        |  +--rw profile-name?         leafref
                       |        +--:(customer-profile)
                       |           +--rw customer-key-chain?
                       |                   kc:key-chain-ref
                       +--rw service
                           ... ]]></artwork>
                </figure></t>
            </section>

            <section title="Services">
              <t>The 'services' container specifies the service parameters to
              apply for a given VPN network access (<xref
              target="services"></xref>).</t>

              <t><figure align="center" anchor="services"
                  title="Services Subtree Structure">
                  <artwork align="center"><![CDATA[                 ...
                 +--rw vpn-network-accesses
                 |  +--rw vpn-network-access* [id]
                 |     +--rw id
                 |     |       vpn-common:vpn-id
                 |     ...
                 |     +--rw service
                 |        +--rw svc-input-bandwidth     uint64
                 |        +--rw svc-output-bandwidth    uint64
                 |        +--rw svc-mtu                 uint16
                 |        +--rw qos {vpn-common:qos}?
                 |        |  +--rw qos-classification-policy
                 |        |  |  +--rw rule* [id]
                 |        |  |     +--rw id
                 |        |  |     |       string
                 |        |  |     +--rw (match-type)?
                 |        |  |     |  +--:(match-flow)
                 |        |  |     |  |  +--rw (l3)?
                 |        |  |     |  |  |  +--:(ipv4)
                 |        |  |     |  |  |  |  ...
                 |        |  |     |  |  |  +--:(ipv6)
                 |        |  |     |  |  |     ...
                 |        |  |     |  |  +--rw (l4)?
                 |        |  |     |  |     +--:(tcp)
                 |        |  |     |  |     |  ...
                 |        |  |     |  |     +--:(udp)
                 |        |  |     |  |        ...
                 |        |  |     |  +--:(match-application)
                 |        |  |     |     +--rw match-application?
                 |        |  |     |             identityref
                 |        |  |     +--rw target-class-id?
                 |        |  |             string
                 |        |  +--rw qos-profile
                 |        |     +--rw qos-profile* [profile]
                 |        |        +--rw profile      leafref
                 |        |        +--rw direction?   identityref
                 |        +--rw carrierscarrier
                 |        |       {vpn-common:carrierscarrier}?
                 |        |  +--rw signalling-type?   enumeration
                 |        +--rw multicast {vpn-common:multicast}?
                 |           +--rw site-type?        enumeration
                 |           +--rw address-family?
                 |           |       vpn-common:address-family
                 |           +--rw protocol-type?    enumeration
                 |           +--rw remote-source?    boolean
                 ...
]]></artwork>
                </figure>The following attributes are defined: <list
                  style="symbols">
                  <t>'svc-input-bandwidth': Indicates the inbound bandwidth of
                  the connection (i.e., download bandwidth from the SP to the
                  site).</t>

                  <t>'svc-output-bandwidth': Indicates the outbound bandwidth
                  of the connection (i.e., upload bandwidth from the site to
                  the SP).</t>

                  <t>'svc-mtu': Indicates the MTU at service level. It can be
                  the IP MTU or MPLS MTU, for example.</t>

                  <t>'carrierscarrier': Groups a set of parameters that are
                  used when CsC is enabled such the use of BGP for signalling
                  purposes <xref target="RFC8277"></xref>.</t>

                  <t>'multicast': Specifies the multicast mode and other
                  service-related attributes such as the address-family.</t>

                  <t>'qos': Is used to define QoS policies to apply on a given
                  connection. Classification can be based on many criteria
                  such as: <list style="symbols">
                      <t>Layer 3: As shown in <xref
                      target="services-l4"></xref>, the model allow to
                      classify based on any IP header field or a combination
                      thereof. Both IPv4 and IPv6 are supported. <figure
                          align="center" anchor="services-l3"
                          title="QoS Subtree Structure (L3)">
                          <artwork align="center"><![CDATA[+--rw qos {vpn-common:qos}?
|  +--rw qos-classification-policy
|  |  +--rw rule* [id]
|  |     +--rw id
|  |     |       string
|  |     +--rw (match-type)?
|  |     |  +--:(match-flow)
|  |     |  |  +--rw (l3)?
|  |     |  |  |  +--:(ipv4)
|  |     |  |  |  |  ...
|  |     |  |  |  +--:(ipv6)
|  |     |  |  |     ...
|  |     |  |  +--rw (l4)?
|  |     |  |  +--rw (l3)?
|  |     |  |  |  +--:(ipv4)
|  |     |  |  |  |  +--rw ipv4
|  |     |  |  |  |     +--rw dscp?
|  |     |  |  |  |     |       inet:dscp
|  |     |  |  |  |     +--rw ecn?
|  |     |  |  |  |     |       uint8
|  |     |  |  |  |     +--rw length?
|  |     |  |  |  |     |       uint16
|  |     |  |  |  |     +--rw ttl?
|  |     |  |  |  |     |       uint8
|  |     |  |  |  |     +--rw protocol?
|  |     |  |  |  |     |       uint8
|  |     |  |  |  |     +--rw ihl?
|  |     |  |  |  |     |       uint8
|  |     |  |  |  |     +--rw flags?
|  |     |  |  |  |     |       bits
|  |     |  |  |  |     +--rw offset?
|  |     |  |  |  |     |       uint16
|  |     |  |  |  |     +--rw identification?
|  |     |  |  |  |     |       uint16
|  |     |  |  |  |     +--rw (destination-network)?
|  |     |  |  |  |     |  +--:(destination-ipv4-network)
|  |     |  |  |  |     |     +--rw destination-ipv4-network?
|  |     |  |  |  |     |             inet:ipv4-prefix
|  |     |  |  |  |     +--rw (source-network)?
|  |     |  |  |  |        +--:(source-ipv4-network)
|  |     |  |  |  |           +--rw source-ipv4-network?
|  |     |  |  |  |  inet:ipv4-prefix
|  |     |  |  |  +--:(ipv6)
|  |     |  |  |     +--rw ipv6
|  |     |  |  |        +--rw dscp?
|  |     |  |  |        |       inet:dscp
|  |     |  |  |        +--rw ecn?
|  |     |  |  |        |       uint8
|  |     |  |  |        +--rw length?
|  |     |  |  |        |       uint16
|  |     |  |  |        +--rw ttl?
|  |     |  |  |        |       uint8
|  |     |  |  |        +--rw protocol?
|  |     |  |  |        |       uint8
|  |     |  |  |        +--rw (destination-network)?
|  |     |  |  |        |  +--:(destination-ipv6-network)
|  |     |  |  |        |     +--rw destination-ipv6-network?
|  |     |  |  |        |             inet:ipv6-prefix
|  |     |  |  |        +--rw (source-network)?
|  |     |  |  |        |  +--:(source-ipv6-network)
|  |     |  |  |        |     +--rw source-ipv6-network?
|  |     |  |  |        |             inet:ipv6-prefix
|  |     |  |  |        +--rw flow-label?
|  |     |  |  |                   inet:ipv6-flow-label
|  |     |  |  +--rw (l4)?
|  |     |  |     +--:(tcp)
|  |     |  |     |  ...
|  |     |  |     +--:(udp)
|  |     |  |        ...
...
]]></artwork>
                        </figure></t>

                      <t>Layer 4: As shown in <xref
                      target="services-l4"></xref>, TCP or UDP-related match
                      crietria can be specified. <figure align="center"
                          anchor="services-l4"
                          title="QoS Subtree Structure (L4)">
                          <artwork align="center"><![CDATA[+--rw qos {vpn-common:qos}?
|  +--rw qos-classification-policy
|  |  +--rw rule* [id]
|  |     +--rw id
|  |     |       string
|  |     +--rw (match-type)?
|  |     |  +--:(match-flow)
|  |     |  |  +--rw (l3)?
|  |     |  |  |  +--:(ipv4)
|  |     |  |  |  |  ...
|  |     |  |  |  +--:(ipv6)
|  |     |  |  |     ...
|  |     |  |  +--rw (l4)?
|  |     |  |     +--:(tcp)
|  |     |  |     |  +--rw tcp
|  |     |  |     |     +--rw sequence-number?
|  |     |  |     |     |       uint32
|  |     |  |     |     +--rw acknowledgement-number?
|  |     |  |     |     |       uint32
|  |     |  |     |     +--rw data-offset?
|  |     |  |     |     |       uint8
|  |     |  |     |     +--rw reserved?
|  |     |  |     |     |       uint8
|  |     |  |     |     +--rw flags?
|  |     |  |     |     |       bits
|  |     |  |     |     +--rw window-size?
|  |     |  |     |     |       uint16
|  |     |  |     |     +--rw urgent-pointer?
|  |     |  |     |     |       uint16
|  |     |  |     |     +--rw options?
|  |     |  |     |     |       binary
|  |     |  |     |     +--rw (source-port)?
|  |     |  |     |     |  +--:(source-port-range-or-operator)
|  |     |  |     |     |     +--rw source-port-range-or-operator
|  |     |  |     |     |        +--rw (port-range-or-operator)?
|  |     |  |     |     |           +--:(range)
|  |     |  |     |     |           |  +--rw lower-port
|  |     |  |     |     |           |  |       inet:port-number
|  |     |  |     |     |           |  +--rw upper-port
|  |     |  |     |     |           |          inet:port-number
|  |     |  |     |     |           +--:(operator)
|  |     |  |     |     |              +--rw operator?
|  |     |  |     |     |              |       operator
|  |     |  |     |     |              +--rw port
|  |     |  |     |     |                      inet:port-number
|  |     |  |     |     +--rw (destination-port)?
|  |     |  |     +--:(destination-port-range-or-operator)
|  |     |  |     |          +--rw destination-port-range-or-operator
|  |     |  |     |             +--rw (port-range-or-operator)?
|  |     |  |     |                +--:(range)
|  |     |  |     |                |  +--rw lower-port
|  |     |  |     |                |  |       inet:port-number
|  |     |  |     |                |  +--rw upper-port
|  |     |  |     |                |          inet:port-number
|  |     |  |     |                +--:(operator)
|  |     |  |     |                   +--rw operator?
|  |     |  |     |                   |       operator
|  |     |  |     |                   +--rw port
|  |     |  |     |                           inet:port-number
|  |     |  |     +--:(udp)
|  |     |  |        +--rw udp
|  |     |  |           +--rw length?
|  |     |  |           |       uint16
|  |     |  |           +--rw (source-port)?
|  |     |  |           |  +--:(source-port-range-or-operator)
|  |     |  |           |     +--rw source-port-range-or-operator
|  |     |  |           |        +--rw (port-range-or-operator)?
|  |     |  |           |           +--:(range)
|  |     |  |           |           |  +--rw lower-port
|  |     |  |           |           |  |       inet:port-number
|  |     |  |           |           |  +--rw upper-port
|  |     |  |           |           |          inet:port-number
|  |     |  |           |           +--:(operator)
|  |     |  |           |              +--rw operator?
|  |     |  |           |              |       operator
|  |     |  |           |              +--rw port
|  |     |  |           |                      inet:port-number
|  |     |  |           +--rw (destination-port)?
|  |     |  |              +--:(destination-port-range-or-operator)
|  |     |  |                +--rw destination-port-range-or-operator
|  |     |  |                    +--rw (port-range-or-operator)?
|  |     |  |                       +--:(range)
|  |     |  |                       |  +--rw lower-port
|  |     |  |                       |  |       inet:port-number
|  |     |  |                       |  +--rw upper-port
|  |     |  |                       |          inet:port-number
|  |     |  |                       +--:(operator)
|  |     |  |                          +--rw operator?
|  |     |  |                          |       operator
|  |     |  |                          +--rw port
|  |     |  |                                  inet:port-number
                 ...
]]></artwork>
                        </figure></t>

                      <t>Application match</t>
                    </list></t>
                </list></t>

              <t></t>
            </section>
          </section>
        </section>
      </section>
    </section>

    <section anchor="YANG_module" title="Layer 3 Network Model">
      <t>This module uses types defined in <xref target="RFC6991"></xref> and
      groupings defined in <xref target="RFC8519"></xref>.</t>

      <figure align="center" anchor="module_YANG">
        <artwork align="center"><![CDATA[<CODE BEGINS>  file "ietf-l3vpn-ntw@2021-01-26.yang"
module ietf-l3vpn-ntw {
  yang-version 1.1;
  namespace "urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw";
  prefix l3nm;

  import ietf-vpn-common {
    prefix vpn-common;
    reference
      "RFC UUUU: A Layer 2/3 VPN Common YANG Model";
  }
  import ietf-inet-types {
    prefix inet;
    reference
      "Section 4 of RFC 6991";
  }
  import ietf-yang-types {
    prefix yang;
    reference
      "Section 3 of RFC 6991";
  }
  import ietf-key-chain {
    prefix kc;
    reference
      "RFC 8177: YANG Key Chain.";
  }

  organization
    "IETF OPSA (Operations and Management Area) Working Group ";
  contact
    "WG Web:   <http://tools.ietf.org/wg/opsawg/>
     WG List:  <mailto:opsawg@ietf.org>

     Editor:    Samier Barguil
                <mailto:samier.barguilgiraldo.ext@telefonica.com>
     Editor:    Oscar Gonzalez de Dios
                <mailto:oscar.gonzalezdedios@telefonica.com>
     Editor:    Mohamed Boucadair
                <mailto:mohamed.boucadair@orange.com>
     Author:    Luis Angel Munoz
                <mailto:luis-angel.munoz@vodafone.com>
     Author:    Alejandro Aguado
                <mailto:alejandro.aguado_martin@nokia.com>
    ";
  description
    "This YANG module defines a generic network-oriented model
     for the configuration of Layer 3 Virtual Private Networks.

     Copyright (c) 2021 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject to
     the license terms contained in, the Simplified BSD License set
     forth in Section 4 of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (https://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC XXXX
     (https://www.rfc-editor.org/info/rfcXXXX); see the RFC itself
     for full legal notices.";

  revision 2021-01-26 {
    description
      "Initial revision.";
    reference
      "RFC XXXX: A Layer 3 VPN Network YANG Model";
  }

  /* Features */

  feature msdp {
    description
      "This feature indicates that Multicast Source Discovery Protocol
       (MSDP) capabilities are supported by the VPN.";
    reference
      "RFC 3618: Multicast Source Discovery Protocol (MSDP)";
  }

  /* Identities */

  identity address-allocation-type {
    description
      "Base identity for address allocation type in the
       Provider Edge (PE)-Customer Edge (CE) link.";
  }

  identity provider-dhcp {
    base address-allocation-type;
    description
      "The Provider's network provides a DHCP service to the customer.";
  }

  identity provider-dhcp-relay {
    base address-allocation-type;
    description
      "The Provider's network provides a DHCP relay service to the
       customer.";
  }

  identity provider-dhcp-slaac {
    base address-allocation-type;
    description
      "The Provider's network provides a DHCP service to the customer
       as well as IPv6 Stateless Address Autoconfiguration (SLAAC).";
    reference
      "RFC 7527: IPv6 Stateless Address Autoconfiguration";
  }

  identity static-address {
    base address-allocation-type;
    description
      "The Provider-to-customer addressing is static.";
  }

  identity slaac {
    if-feature "vpn-common:ipv6";
    base address-allocation-type;
    description
      "Use IPv6 SLAAC.";
    reference
      "RFC 7527: IPv6 Stateless Address Autoconfiguration";
  }

  identity bearer-inf-type {
    description
      "Identity for the bearer interface type.";
  }

  identity port-id {
    base bearer-inf-type;
    description
      "Identity for the priority-tagged interface.";
  }

  identity lag-id {
    base bearer-inf-type;
    description
      "Identity for the lag-tagged interface.";
  }

  identity local-defined-next-hop {
    description
      "Defines a base identity type of local defined
       next-hops.";
  }

  identity discard {
    base local-defined-next-hop;
    description
      "Indicates an action to discard traffic for the
       corresponding destination.
       For example, this can be used to blackhole traffic.";
  }

  identity local-link {
    base local-defined-next-hop;
    description
      "Treat traffic towards addresses within the specified next-hop
       prefix as though they are connected to a local link.";
  }

  typedef predefined-next-hop {
    type identityref {
      base local-defined-next-hop;
    }
    description
      "Pre-defined next-hop designation for locally generated routes.";
  }

  /* Typedefs */

  typedef area-address {
    type string {
      pattern '[0-9A-Fa-f]{2}(\.[0-9A-Fa-f]{4}){0,6}';
    }
    description
      "This type defines the area address format.";
  }

  /* Groupings */

  grouping security-params {
    description
      "Grouping to define a set of security parameters.";
    container security {
      description
        "Container for aggregating any security parameters
         for routing sessions between a PE and a CE.";
      leaf enable {
        type boolean;
        default "false";
        description
          "Enables or disables authentication.";
      }
      container keying-material {
        when "../enable = 'true'";
        description
          "Container for describing how a routing session
           is to be secured between a CE and a PE.";
        choice option {
          description
            "Choice of authentication options.";
          case md5 {
            description
              "Uses MD5 to secure the session.";
            reference
              "Section 13.2 of RFC 4364";
            leaf md5-keychain {
              type kc:key-chain-ref;
              description
                "Reference to the MD5 key chain.";
              reference
                "RFC 8177: YANG Key Chain.";
            }
          }
          case ipsec {
            description
              "Specifies a reference to an IKE Security
               Association (SA).";
            leaf sa {
              type string;
              description
                "Indicates the name of the SA.";
            }
          }
        }
      }
    }
  }

  /* Main Blocks */
  /* Main l3vpn-ntw */

  container l3vpn-ntw {
    description
      "Main container for L3VPN services management.";
    container vpn-profiles {
      description
        "Contains a set of valid VPN Profiles to reference in the VPN
         service.";
      uses vpn-common:vpn-profile-cfg;
    }
    container vpn-services {
      description
        "Top-level container for the VPN services.";
      list vpn-service {
        key "vpn-id";
        description
          "List of VPN services.";
        uses vpn-common:vpn-description;
        leaf l3sm-vpn-id {
          type vpn-common:vpn-id;
          description
            "Pointer to the parent L3SM service,
             if any.";
        }
        leaf vpn-type {
          type identityref {
            base vpn-common:service-type;
          }
          description
            "Indicates the service type.";
        }
        leaf vpn-service-topology {
          type identityref {
            base vpn-common:vpn-topology;
          }
          default "vpn-common:any-to-any";
          description
            "VPN service topology.";
        }
        uses vpn-common:service-status;
        container ie-profiles {
          description
            "Container for Import/Export profiles.";
          list ie-profile {
            key "ie-profile-id";
            description
              "List for Imort/Export profile.";
            leaf ie-profile-id {
              type string;
              description
                "IE profile id.";
            }
            uses vpn-common:rt-rd;
          }
        }
        uses vpn-common:svc-transport-encapsulation;
        container external-connectivity {
          description
            "Container for external connectivity.";
          choice profile {
            description
              "Choice for the external connectivity profile.";
            case profile {
              leaf profile-name {
                type leafref {
                  path "/l3vpn-ntw/vpn-profiles"
                     + "/valid-provider-identifiers"
                     + "/external-connectivity-identifier/id";
                }
                description
                  "Name of the service provider's profile
                   to be applied at the service level.";
              }
            }
          }
        }
        container vpn-nodes {
          description
            "Container for VPN nodes.";
          list vpn-node {
            key "vpn-node-id";
            description
              "List for VPN node.";
            leaf vpn-node-id {
              type union {
                type vpn-common:vpn-id;
                type uint32;
              }
              description
                "Type STRING or NUMBER identifier.";
            }
            leaf description {
              type string;
              description
                "Textual description of the VPN node.";
            }
            leaf ne-id {
              type string;
              description
                "Unique identifier of the network element
                 where the VPN node is deployed.";
            }
            leaf node-role {
              type identityref {
                base vpn-common:role;
              }
              default "vpn-common:any-to-any-role";
              description
                "Role of the VPN node in the IP VPN.";
            }
            leaf local-autonomous-system {
              if-feature "vpn-common:rtg-bgp";
              type inet:as-number;
              description
                "Provider's AS number in case the customer
                 requests BGP routing.";
            }
            leaf address-family {
              type identityref {
                base vpn-common:address-family;
              }
              description
                "The address family used for router-id
                 information.";
            }
            leaf router-id {
              type inet:ip-address;
              description
                "The router-id information can be an IPv4
                 or IPv6 address.";
            }
            uses vpn-common:rt-rd;
            leaf node-ie-profile {
              type leafref {
                path "/l3vpn-ntw/vpn-services"
                   + "/vpn-service/ie-profiles"
                   + "/ie-profile/ie-profile-id";
              }
              description
                "Node's Import/Export profile.";
            }
            container maximum-routes {
              description
                "Defines 'maximum-routes' for the VRF.";
              list address-family {
                key "af";
                description
                  "List of address families.";
                leaf af {
                  type identityref {
                    base vpn-common:address-family;
                  }
                  description
                    "Indicates the address family
                     (IPv4 or IPv6).";
                }
                leaf maximum-routes {
                  type uint32;
                  description
                    "Indicates the maximum prefixes the VRF
                     can accept for this address family.";
                }
              }
              uses vpn-common:service-status;
            }
            uses vpn-common:vpn-components-group;
            container multicast {
              if-feature "vpn-common:multicast";
              description
                "Multicast global parameters for the VPN
                 service.";
              leaf enabled {
                type boolean;
                default "false";
                description
                  "Enables multicast.";
              }
              leaf-list tree-flavor {
                type identityref {
                  base vpn-common:multicast-tree-type;
                }
                description
                  "Type of tree to be used.";
              }
              container rp {
                description
                  "RP parameters.";
                container rp-group-mappings {
                  description
                    "RP-to-group mappings parameters.";
                  list rp-group-mapping {
                    key "id";
                    description
                      "List of RP-to-group mappings.";
                    leaf id {
                      type uint16;
                      description
                        "Unique identifier for the mapping.";
                    }
                    container provider-managed {
                      description
                        "Parameters for a provider-managed RP.";
                      leaf enabled {
                        type boolean;
                        default "false";
                        description
                          "Set to true if the Rendezvous Point (RP)
                           must be a provider-managed node.  Set to
                           false if it is a customer-managed node.";
                      }
                      leaf rp-redundancy {
                        type boolean;
                        default "false";
                        description
                          "If true, a redundancy mechanism for the
                           RP is required.";
                      }
                      leaf optimal-traffic-delivery {
                        type boolean;
                        default "false";
                        description
                          "If true, the SP must ensure that
                           traffic uses an optimal path.  An SP may
                           use Anycast RP or RP-tree-to-SPT
                           switchover architectures.";
                      }
                      container anycast {
                        when "../rp-redundancy = 'true' and
                              ../optimal-traffic-delivery = 'true'" {
                          description
                            "Only applicable if
                             RP redundancy is
                             enabled and delivery through
                             optimal path is activated.";
                        }
                        description
                          "PIM Anycast-RP parameters.";
                        leaf local-address {
                          type inet:ip-address;
                          description
                            "IP local address for PIM RP.
                             Usually, it corresponds to router
                             ID or primary address";
                        }
                        leaf-list rp-set-address {
                          type inet:ip-address;
                          description
                            "Address other RP routers
                             that share the same RP IP address.";
                        }
                      }
                    }
                    leaf rp-address {
                      when "../provider-managed/enabled = 'false'" {
                        description
                          "Relevant when the RP is not
                           provider-managed.";
                      }
                      type inet:ip-address;
                      mandatory true;
                      description
                        "Defines the address of the RP.
                         Used if the RP is customer-managed.";
                    }
                    container groups {
                      description
                        "Multicast groups associated with the RP.";
                      list group {
                        key "id";
                        description
                          "List of multicast groups.";
                        leaf id {
                          type uint16;
                          description
                            "Identifier for the group.";
                        }
                        choice group-format {
                          mandatory true;
                          description
                            "Choice for multicast group format.";
                          case group-prefix {
                            leaf group-address {
                              type inet:ip-prefix;
                              description
                                "A single multicast group prefix.";
                            }
                          }
                          case startend {
                            leaf group-start {
                              type inet:ip-address;
                              description
                                "The first multicast group address in
                                 the multicast group address range.";
                            }
                            leaf group-end {
                              type inet:ip-address;
                              description
                                "The last multicast group address in
                                 the multicast group address range.";
                            }
                          }
                        }
                      }
                    }
                  }
                }
                container rp-discovery {
                  description
                    "RP discovery parameters.";
                  leaf rp-discovery-type {
                    type identityref {
                      base vpn-common:multicast-rp-discovery-type;
                    }
                    default "vpn-common:static-rp";
                    description
                      "Type of RP discovery used.";
                  }
                  container bsr-candidates {
                    when "derived-from-or-self(../rp-discovery-type, "
                       + "'vpn-common:bsr-rp')" {
                      description
                        "Only applicable if discovery type is BSR-RP.";
                    }
                    description
                      "Container for List of Customer
                       BSR candidate's addresses.";
                    leaf-list bsr-candidate-address {
                      type inet:ip-address;
                      description
                        "Specifies the address of candidate Bootstrap
                         Router (BSR).";
                    }
                  }
                }
              }
              container msdp {
                if-feature "msdp";
                description
                  "Includes MSDP-related parameters.";
                leaf enabled {
                  type boolean;
                  default "false";
                  description
                    "If set to true, it indicates that MSDP is
                     activated.";
                }
                leaf peer {
                  type inet:ip-address;
                  description
                    "Indicates the IP address of the MSDP peer.";
                }
                leaf local-address {
                  type inet:ip-address;
                  description
                    "Indicates the IP address of the local end.
                     This local address must be configured on
                     the node.";
                }
              }
            }
            container vpn-network-accesses {
              description
                "List of network accesses.";
              list vpn-network-access {
                key "id";
                description
                  "List of network accesses.";
                leaf id {
                  type vpn-common:vpn-id;
                  description
                    "Identifier for the access.";
                }
                leaf port-id {
                  type vpn-common:vpn-id;
                  description
                    "Identifier for the network access.";
                }
                leaf description {
                  type string;
                  description
                    "Textual description of a network access.";
                }
                leaf vpn-network-access-type {
                  type identityref {
                    base vpn-common:site-network-access-type;
                  }
                  default "vpn-common:point-to-point";
                  description
                    "Describes the type of connection, e.g.,
                     point-to-point or multipoint.";
                }
                uses vpn-common:service-status;
                container connection {
                  description
                    "Encapsulation types.";
                  leaf encapsulation-type {
                    type identityref {
                      base vpn-common:encapsulation-type;
                    }
                    default "vpn-common:untagged-int";
                    description
                      "Encapsulation type. By default,
                       the encapsulation type is set to
                       'untagged'.";
                  }
                  container logical-interface {
                    description
                      "Reference of a logical interface
                       type.";
                    leaf peer-reference {
                      type uint32;
                      description
                        "Specifies the associated logical peer
                         interface.";
                    }
                  }
                  container tagged-interface {
                    description
                      "Container for tagged interfaces.";
                    leaf type {
                      type identityref {
                        base vpn-common:encapsulation-type;
                      }
                      default "vpn-common:priority-tagged";
                      description
                        "Tagged interface type. By default,
                         the type of the tagged interface is
                         'priority-tagged'.";
                    }
                    container dot1q-vlan-tagged {
                      when "derived-from-or-self(../type, "
                         + "'vpn-common:dot1q')" {
                        description
                          "Only applies when the type of the
                           tagged interface is 'dot1q'.";
                      }
                      if-feature "vpn-common:dot1q";
                      description
                        "Tagged interface.";
                      leaf tag-type {
                        type identityref {
                          base vpn-common:tag-type;
                        }
                        default "vpn-common:c-vlan";
                        description
                          "Tag type. By default, the tag
                           type is 'c-vlan'.";
                      }
                      leaf cvlan-id {
                        type uint16;
                        description
                          "VLAN identifier.";
                      }
                    }
                    container priority-tagged {
                      when "derived-from-or-self(../type, "
                         + "'vpn-common:priority-tagged')" {
                        description
                          "Only applies when the type of the
                           tagged interface is
                           'priority-tagged'.";
                      }
                      description
                        "Priority tagged.";
                      leaf tag-type {
                        type identityref {
                          base vpn-common:tag-type;
                        }
                        default "vpn-common:c-vlan";
                        description
                          "Tag type. By default, the tag
                           type is 'c-vlan'.";
                      }
                    }
                    container qinq {
                      when "derived-from-or-self(../type, "
                         + "'vpn-common:qinq')" {
                        description
                          "Only applies when the type of
                           the tagged interface is 'qinq'.";
                      }
                      if-feature "vpn-common:qinq";
                      description
                        "QinQ.";
                      leaf tag-type {
                        type identityref {
                          base vpn-common:tag-type;
                        }
                        default "vpn-common:c-s-vlan";
                        description
                          "Tag type. By default, the tag
                           type is 'c-s-vlan'.";
                      }
                      leaf svlan-id {
                        type uint16;
                        mandatory true;
                        description
                          "SVLAN identifier.";
                      }
                      leaf cvlan-id {
                        type uint16;
                        mandatory true;
                        description
                          "CVLAN identifier.";
                      }
                    }
                    container qinany {
                      when "derived-from-or-self(../type, "
                         + "'vpn-common:qinany')" {
                        description
                          "Only applies when the type of the
                           tagged interface is 'qinany'.";
                      }
                      if-feature "vpn-common:qinany";
                      description
                        "Container for QinAny.";
                      leaf tag-type {
                        type identityref {
                          base vpn-common:tag-type;
                        }
                        default "vpn-common:s-vlan";
                        description
                          "Tag type. By default, the tag type
                           is 's-vlan'.";
                      }
                      leaf svlan-id {
                        type uint16;
                        mandatory true;
                        description
                          "Service VLAN ID.";
                      }
                    }
                    container vxlan {
                      when "derived-from-or-self(../type, "
                         + "'vpn-common:vxlan')" {
                        description
                          "Only applies when the type of the
                           tagged interface is 'vxlan'.";
                      }
                      if-feature "vpn-common:vxlan";
                      description
                        "QinQ.";
                      leaf vni-id {
                        type uint32;
                        mandatory true;
                        description
                          "VXLAN Network Identifier (VNI).";
                      }
                      leaf peer-mode {
                        type identityref {
                          base vpn-common:vxlan-peer-mode;
                        }
                        default "vpn-common:static-mode";
                        description
                          "Specifies the VXLAN access mode.
                           By default, the peer mode is set
                           to 'static-mode'.";
                      }
                      list peer-list {
                        key "peer-ip";
                        description
                          "List of peer IP addresses.";
                        leaf peer-ip {
                          type inet:ip-address;
                          description
                            "Peer IP address.";
                        }
                      }
                    }
                  }
                  container bearer {
                    description
                      "Defines physical properties of a site
                       attachment.";
                    leaf bearer-reference {
                      if-feature "vpn-common:bearer-reference";
                      type string;
                      description
                        "This is an internal reference for
                         the service provider.";
                    }
                    container pseudowire {
                      description
                        "Pseudowire termination parameters";
                      leaf vcid {
                        type uint32;
                        description
                          "Indicates a PW or VC identifier.";
                      }
                      leaf far-end {
                        type union {
                          type uint32;
                          type inet:ip-address;
                        }
                        description
                          "SDP/Far End/LDP neighbour reference.";
                      }
                    }
                    container vpls {
                      description
                        "Pseudowire termination parameters";
                      leaf vcid {
                        type union {
                          type uint32;
                          type string;
                        }
                        description
                          "VCID identifier, IRB/RVPPLs interface
                           supported using string format.";
                      }
                      leaf far-end {
                        type union {
                          type uint32;
                          type inet:ip-address;
                        }
                        description
                          "SDP/Far End/LDP Neighbour reference.";
                      }
                    }
                  }
                }
                container ip-connection {
                  description
                    "Defines connection parameters.";
                  container ipv4 {
                    if-feature "vpn-common:ipv4";
                    description
                      "IPv4-specific parameters.";
                    leaf address-allocation-type {
                      type identityref {
                        base address-allocation-type;
                      }
                      must "not(derived-from-or-self(current(), "
                         + "'slaac') or derived-from-or-self(current(),"
                         + " 'provider-dhcp-slaac'))" {
                        error-message "SLAAC is only applicable to IPv6.";
                      }
                      description
                        "Defines how addresses are allocated.
                         If there is no value for the address
                         allocation type, then IPv4 is not enabled.";
                    }
                    choice allocation-type {
                      description
                        "Choice the address allocation.";
                      case provider-dhcp {
                        when "derived-from-or-self(./address-"
                           + "allocation-type, 'provider-dhcp')" {
                          description
                            "Only applies when addresses are
                             allocated by DHCP.";
                        }
                        description
                          "DHCP allocated addresses related
                           parameters.";
                        leaf provider-address {
                          type inet:ipv4-address;
                          description
                            "Address used at provider side.

                             If provider-address is not specified,
                             then prefix length should not be
                             specified either.

                             It also implies provider-dhcp
                             allocation is not enabled.

                             If provider-address is specified,
                             then the prefix length may or
                             may not be specified.";
                        }
                        leaf prefix-length {
                          type uint8 {
                            range "0..32";
                          }
                          must '(../provider-address)' {
                            error-message
                              "If the prefix length is specified,
                               provider-address must also be
                               specified.";
                            description
                              "If the prefix length is specified,
                               provider-address must also be
                               specified.";
                          }
                          description
                            "Subnet prefix length expressed in bits.
                             If not specified, or specified as zero,
                             this means the customer leaves the actual
                             prefix length value to the provider.";
                        }
                        choice address-assign {
                          default "number";
                          description
                            "Choice for the way to assign
                             addresses.";
                          case number {
                            leaf number-of-dynamic-address {
                              type uint16;
                              default "1";
                              description
                                "Describes the number of IP
                                 addresses the customer requires.";
                            }
                          }
                          case explicit {
                            container customer-addresses {
                              description
                                "Container for customer addresses is
                                 allocated by DHCP.";
                              list address-group {
                                key "group-id";
                                description
                                  "Describes IP addresses allocated by
                                   DHCP.

                                   When only start-address or only
                                   end-address is present, it
                                   represents a single address.
                                   When both start-address and
                                   end-address are specified, it
                                   implies a range inclusive of
                                   both addresses.  If no address
                                   is specified, it implies customer
                                   addresses group is not supported.";
                                leaf group-id {
                                  type string;
                                  description
                                    "Group-id for the address range
                                     from start-address to
                                     end-address.";
                                }
                                leaf start-address {
                                  type inet:ipv4-address;
                                  description
                                    "Indicates the first address in the group.";
                                }
                                leaf end-address {
                                  type inet:ipv4-address;
                                  description
                                    "Indicates the last address in the group.";
                                }
                              }
                            }
                          }
                        }
                      }
                      case dhcp-relay {
                        when "derived-from-or-self(./address-allocation"
                           + "-type, 'provider-dhcp-relay')" {
                          description
                            "Only applies when the provider is required to
                             implement DHCP relay function.";
                        }
                        description
                          "DHCP relay provided by operator.";
                        leaf dr-provider-address {
                          type inet:ipv4-address;
                          description
                            "Address of the provider side.

                             If provider-address is
                             not specified, then prefix length
                             should not be specified either.

                             It also implies provider-dhcp
                             allocation is not enabled.

                             If provider-address is specified,
                             then prefix length may or may
                             not be specified.";
                        }
                        leaf dr-prefix-length {
                          type uint8 {
                            range "0..32";
                          }
                          must '(../dr-provider-address)' {
                            error-message
                              "If prefix length is specified,
                               provider-address must also be
                               specified.";
                            description
                              "If prefix length is specified,
                               provider-address must also be
                               specified.";
                          }
                          description
                            "Subnet prefix length expressed in bits.

                             If not specified, or specified as zero,
                             this means the customer leaves the
                             actual prefix  length value
                             to the provider.";
                        }
                        container customer-dhcp-servers {
                          description
                            "Container for list of customer
                             DHCP servers.";
                          leaf-list server-ip-address {
                            type inet:ipv4-address;
                            description
                              "IP address of customer DHCP server.";
                          }
                        }
                      }
                      case static-addresses {
                        when "derived-from-or-self(./address-allocation"
                           + "-type, 'static-address')" {
                          description
                            "Only applies when address allocation
                             type is static.";
                        }
                        description
                          "Describes IPv4 addresses used.";
                        leaf primary-address {
                          type leafref {
                            path "../address/address-id";
                          }
                          description
                            "Primary address of the connection.";
                        }
                        list address {
                          key "address-id";
                          description
                            "Describes IPv4 addresses used.";
                          leaf address-id {
                            type string;
                            description
                              "Used static IPv4 address.";
                          }
                          leaf s-provider-address {
                            type inet:ipv4-address;
                            description
                              "IPv4 Address List of the provider side.
                               When the protocol allocation type is
                               static, the provider address must be
                               configured.";
                          }
                          leaf s-customer-address {
                            type inet:ipv4-address;
                            description
                              "IPv4 address at the customer side.";
                          }
                          leaf s-prefix-length {
                            type uint8 {
                              range "0..32";
                            }
                            description
                              "Subnet prefix length expressed
                               in bits. It is applied to both
                               provider-address and customer-address.";
                          }
                        }
                      }
                    }
                  }
                  container ipv6 {
                    if-feature "vpn-common:ipv6";
                    description
                      "IPv6-specific parameters.";
                    leaf address-allocation-type {
                      type identityref {
                        base address-allocation-type;
                      }
                      description
                        "Defines how addresses are allocated.
                         If there is no value for the address
                         allocation type, then IPv6 is
                         not enabled.";
                    }
                    choice allocation-type {
                      description
                        "IPv6 allocation type.";
                      choice provider-dhcp {
                        when "derived-from-or-self(./address-allo"
                           + "cation-type, 'provider-dhcp') "
                           + "or derived-from-or-self(./address-allo"
                           + "cation-type, 'provider-dhcp-slaac')" {
                          description
                            "Only applies when addresses are
                             allocated by DHCP.";
                        }
                        description
                          "DHCP allocated addresses related
                           parameters.";
                        leaf provider-address {
                          type inet:ipv6-address;
                          description
                            "Address of the provider side.

                             If provider-address is not specified,
                             then prefix length should not be
                             specified either.  It also implies
                             provider-dhcp allocation is not
                             enabled.

                             If provider-address is
                             specified, then prefix length may
                             or may not be specified.";
                        }
                        leaf prefix-length {
                          type uint8 {
                            range "0..128";
                          }
                          must '(../provider-address)' {
                            error-message
                              "If prefix length is specified,
                               provider-address
                               must also be specified.";
                            description
                              "If prefix length is specified,
                                provider-address
                               must also be specified.";
                          }
                          description
                            "Subnet prefix length expressed in
                             bits.

                             If not specified, or specified as
                             zero, this means the customer leaves
                             the actual prefix length value to
                             the provider.";
                        }
                        choice address-assign {
                          default "number";
                          description
                            "Choice for the way to assign addresses.";
                          case number {
                            leaf number-of-dynamic-address {
                              type uint16;
                              default "1";
                              description
                                "Describes the number of IP
                                 addresses required by the
                                 customer.";
                            }
                          }
                          case explicit {
                            container customer-addresses {
                              description
                                "Container for customer addresses
                                 allocated by DHCP.";
                              list address-group {
                                key "group-id";
                                description
                                  "Describes IP addresses allocated
                                   by DHCP.

                                   When only start-address or only
                                   end-address is present, it
                                   represents a single address.

                                   When both start-address and
                                   end-address are specified, it
                                   implies a range inclusive of
                                   both addresses.

                                   If no address is specified, it
                                   implies customer addresses group
                                   is not supported.";
                                leaf group-id {
                                  type string;
                                  description
                                    "Group-id for the address range
                                     from identified by start-address
                                     and end-address.";
                                }
                                leaf start-address {
                                  type inet:ipv6-address;
                                  description
                                    "First address.";
                                }
                                leaf end-address {
                                  type inet:ipv6-address;
                                  description
                                    "Last address.";
                                }
                              }
                            }
                          }
                        }
                      }
                      case dhcp-relay {
                        when "derived-from-or-self(./address-allo"
                           + "cation-type, 'provider-dhcp-relay')" {
                          description
                            "Only applies when the provider is required
                             to implement DHCP relay function.";
                        }
                        description
                          "DHCP relay provided by operator.";
                        leaf dr-provider-address {
                          type inet:ipv6-address;
                          description
                            "Address of the provider side.

                             If provider-address is not specified,
                             then prefix length should not be
                             specified either.  It also implies
                             provider-dhcp allocation is not enabled.

                             If provider address is specified, then
                             prefix length may or may not be
                             specified.";
                        }
                        leaf dr-prefix-length {
                          type uint8 {
                            range "0..128";
                          }
                          must '(../dr-provider-address)' {
                            error-message
                              "If prefix length is specified,
                               provider-address must also be
                               specified.";
                            description
                              "If prefix length is specified,
                               provider-address must also be
                               specified.";
                          }
                          description
                            "Subnet prefix length expressed in bits.

                             If not specified, or specified as zero,
                             this means the customer leaves the
                             actual prefix length value to the
                             provider.";
                        }
                        container customer-dhcp-servers {
                          description
                            "Container for list of customer DHCP
                             servers.";
                          leaf-list server-ip-address {
                            type inet:ipv6-address;
                            description
                              "This node contains the IP address of
                               the customer DHCP server.  If the DHCP
                               relay function is implemented by the
                               provider, this node contains the
                               configured value.";
                          }
                        }
                      }
                      case static-addresses {
                        when "derived-from-or-self(./address-allocation"
                           + "-type, 'static-address')" {
                          description
                            "Only applies when protocol allocation type
                             is static.";
                        }
                        description
                          "IPv6-specific parameters.";
                        leaf s-primary-address {
                          type leafref {
                            path "../s-address/address-id";
                          }
                          description
                            "Principal address of the connection";
                        }
                        list s-address {
                          key "address-id";
                          description
                            "Describes IPv6 addresses used.";
                          leaf address-id {
                            type string;
                            description
                              "IPv4 Address";
                          }
                          leaf provider-address {
                            type inet:ipv6-address;
                            description
                              "IPv6 Address of the provider side.  When
                               the protocol allocation type is static,
                               the provider address must be
                               configured.";
                          }
                          leaf customer-address {
                            type inet:ipv6-address;
                            description
                              "The IPv6 Address of the customer side.";
                          }
                          leaf prefix-length {
                            type uint8 {
                              range "0..128";
                            }
                            description
                              "Subnet prefix length expressed in bits.
                               It is applied to both provider-address
                               and customer-address.";
                          }
                        }
                      }
                    }
                  }
                  container oam {
                    description
                      "Defines the Operations, Administration,
                       and Maintenance (OAM) mechanisms used on
                       the connection.

                       BFD is set as a fault detection mechanism,
                       but the 'oam' container can easily
                       be augmented by other mechanisms";
                    container bfd {
                      if-feature "vpn-common:bfd";
                      description
                        "Container for BFD.";
                      leaf enabled {
                        type boolean;
                        default "false";
                        description
                          "If true, BFD activation is required.";
                      }
                      choice holdtime {
                        default "fixed";
                        description
                          "Choice for holdtime flavor.";
                        case fixed {
                          leaf fixed-value {
                            type uint32;
                            units "msec";
                            description
                              "Expected BFD holdtime.

                               The customer may impose some fixed
                               values for the holdtime period if the
                               provider allows the customer use this
                               function.

                               If the provider doesn't allow the
                               customer to use this function,
                               the fixed-value will not be set.";
                          }
                        }
                        case profile {
                          description
                            "Well-known SP profile.";
                          leaf profile-name {
                            type leafref {
                              path "/l3vpn-ntw/vpn-profiles"
                                 + "/valid-provider-identifiers"
                                 + "/bfd-profile-identifier/id";
                            }
                            description
                              "Well-known service provider profile name.

                               The provider can propose some profiles
                               to the customer, depending on the
                               service level the customer wants to
                               achieve.

                               Profile names must be communicated to
                               the customer.";
                          }
                        }
                      }
                    }
                  }
                }
                container routing-protocols {
                  description
                    "Defines routing protocols.";
                  list routing-protocol {
                    key "id";
                    description
                      "List of routing protocols used on
                       the site.  This list can be augmented.";
                    leaf id {
                      type string;
                      description
                        "Unique identifier for routing protocol.";
                    }
                    leaf type {
                      type identityref {
                        base vpn-common:routing-protocol-type;
                      }
                      description
                        "Type of routing protocol.";
                    }
                    list routing-profiles {
                      key "id";
                      description
                        "Routing profiles.";
                      leaf id {
                        type leafref {
                          path "/l3vpn-ntw/vpn-profiles"
                             + "/valid-provider-identifiers"
                             + "/routing-profile-identifier/id";
                        }
                        description
                          "Routing profile to be used.";
                      }
                      leaf type {
                        type identityref {
                          base vpn-common:ie-type;
                        }
                        description
                          "Import, export or both.";
                      }
                    }
                    container static {
                      when "derived-from-or-self(../type, "
                         + "'vpn-common:static')" {
                        description
                          "Only applies when protocol is static.

                           BGP activation requires the provider to
                           know the address of the customer peer.
                           When BGP is enabled, the 'static-address'
                           allocation type for the IP connection
                           must be used.";
                      }
                      description
                        "Configuration specific to static routing.";
                      container cascaded-lan-prefixes {
                        description
                          "LAN prefixes from the customer.";
                        list ipv4-lan-prefixes {
                          if-feature "vpn-common:ipv4";
                          key "lan next-hop";
                          description
                            "List of LAN prefixes for the site.";
                          leaf lan {
                            type inet:ipv4-prefix;
                            description
                              "LAN prefixes.";
                          }
                          leaf lan-tag {
                            type string;
                            description
                              "Internal tag to be used in VPN
                               policies.";
                          }
                          leaf next-hop {
                            type union {
                              type inet:ip-address;
                              type predefined-next-hop;
                            }
                            description
                              "The next-hop that is to be used for the
                               static route. This may be specified as an
                               IP address, an interface, or a pre-defined
                               next-hop type (e.g., discard or local-link).";
                          }
                          leaf bfd-enable {
                            type boolean;
                            description
                              "Enables BFD.";
                          }
                          leaf metric {
                            type uint32;
                            description
                              "Indicates the metric associated with
                               the static route.";
                          }
                          leaf preference {
                            type uint32;
                            description
                              "Indicates the preference of the static
                               routes.";
                          }
                        }
                        list ipv6-lan-prefixes {
                          if-feature "vpn-common:ipv6";
                          key "lan next-hop";
                          description
                            "List of LAN prefixes for the site.";
                          leaf lan {
                            type inet:ipv6-prefix;
                            description
                              "LAN prefixes.";
                          }
                          leaf lan-tag {
                            type string;
                            description
                              "Internal tag to be used in VPN
                               policies.";
                          }
                          leaf next-hop {
                            type union {
                              type inet:ip-address;
                              type predefined-next-hop;
                            }
                            description
                              "The next-hop that is to be used for the
                               static route. This may be specified as an
                               IP address, an interface, or a pre-defined
                               next-hop type (e.g., discard or local-link).";
                          }
                          leaf bfd-enable {
                            type boolean;
                            description
                              "Enables BFD.";
                          }
                          leaf metric {
                            type uint32;
                            description
                              "Indicates the metric associated with
                               the static route.";
                          }
                          leaf preference {
                            type uint32;
                            description
                              "Indicates the preference associated
                               with the static route.";
                          }
                        }
                      }
                    }
                    container bgp {
                      when "derived-from-or-self(../type, "
                         + "'vpn-common:bgp')" {
                        description
                          "Only applies when protocol is BGP.";
                      }
                      if-feature "vpn-common:rtg-bgp";
                      description
                        "BGP-specific configuration.";
                      leaf description {
                        type string;
                        description
                          "Includes a description of the BGP session.

                           Such description is meant to be used for
                           diagnosis purposes. The semantic of the
                           description is local to an
                           implementation.";
                      }
                      leaf local-autonomous-system {
                        type inet:as-number;
                        description
                          "Is set to the ASN to override a peers' ASN
                           if such feature is requested by the
                           Customer.";
                      }
                      leaf peer-autonomous-system {
                        type inet:as-number;
                        mandatory true;
                        description
                          "Indicates the Customer's AS Number (ASN) in
                           case the Customer requests BGP routing.";
                      }
                      leaf-list address-family {
                        type identityref {
                          base vpn-common:address-family;
                        }
                        min-elements 1;
                        description
                          "This node contains at least one
                           address family to be activated.";
                      }
                      leaf-list neighbor {
                        type inet:ip-address;
                        description
                          "IP address(es) of the BGP neighbor. IPv4
                           and IPv6 neighbors may be indicated if
                           two sessions will be used for IPv4 and
                           IPv6.";
                      }
                      leaf multihop {
                        type uint8;
                        description
                          "Describes the number of IP hops allowed
                           between a given BGP neighbor and the PE.";
                      }
                      leaf as-override {
                        type boolean;
                        default "false";
                        description
                          "Defines whether AS override is enabled,
                           i.e., replace the ASN of the peer specified
                           in the AS Path attribute with the local
                           AS number.";
                      }
                      leaf default-route {
                        type boolean;
                        default "false";
                        description
                          "Defines whether default route(s) can be
                           advertised to its peer. If set, the
                           default route(s) is advertised to its
                           peer.";
                      }
                      container bgp-max-prefix {
                        description
                          "Controls the behavior when a prefix
                           maximum is reached.";
                        leaf max-prefix {
                          type uint32;
                          default "5000";
                          description
                            "Indicates the maximimum number of BGP
                             prefixes allowed in the BGP session.

                             It allows to control how many prefixes
                             can be received from a neighbor.

                             If the limit is exceeded, the session
                              can be teared down.";
                          reference
                            "RFC4271, Section 8.2.2.";
                        }
                        leaf warning-threshold {
                          type decimal64 {
                            fraction-digits 5;
                            range "0..100";
                          }
                          units "percent";
                          default "75";
                          description
                            "When this value is reached, a warning
                             notification will be triggered.";
                        }
                        leaf violate-action {
                          type enumeration {
                            enum warning {
                              description
                                "Only a warning message is sent to
                                 the peer when the limit is
                                 exceeded.";
                            }
                            enum discard-extra-paths {
                              description
                                "Discards extra paths when the
                                 limit is exceeded.";
                            }
                            enum restart {
                              description
                                "Restart after a time interval.";
                            }
                          }
                          description
                            "BGP neighbour max-prefix violate
                             action";
                        }
                        leaf restart-interval {
                          type uint16;
                          units "minutes";
                          description
                            "Time interval (min) after which the
                             BGP session will be reestablished.";
                        }
                      }
                      container bgp-timer {
                        description
                          "Includes two BGP timers that can be
                           customized when building a VPN service
                           with BGP used as CE-PE routing
                           protocol.";
                        leaf keep-alive {
                          type uint16 {
                            range "0..21845";
                          }
                          units "seconds";
                          default "30";
                          description
                            "This timer indicates the KEEPALIVE
                             messages'  frequency between a PE
                             and a BGP peer.

                             If set to '0', it indicates KEEPALIVE
                             messages are disabled.

                             It is suggested that the maximum time
                             between  KEEPALIVEmessages would be
                             one third of the Hold Time interval.";
                          reference
                            "Section 4.4 of RFC 4271";
                        }
                        leaf hold-time {
                          type uint16 {
                            range "0 | 3..65535";
                          }
                          units "seconds";
                          default "90";
                          description
                            "It indicates the maximum number of
                             seconds that may elapse between the
                             receipt of successive KEEPALIVE
                             and/or UPDATE   messages from the peer.

                             The Hold Time must be either zero or
                             at least three seconds.";
                          reference
                            "Section 4.2 of RFC 4271";
                        }
                      }
                      uses security-params;
                      uses vpn-common:service-status;
                    }
                    container ospf {
                      when "derived-from-or-self(../type, "
                         + "'vpn-common:ospf')" {
                        description
                          "Only applies when protocol is OSPF.";
                      }
                      if-feature "vpn-common:rtg-ospf";
                      description
                        "OSPF-specific configuration.";
                      leaf-list address-family {
                        type identityref {
                          base vpn-common:address-family;
                        }
                        min-elements 1;
                        description
                          "If OSPF is used on this site, this node
                           contains at least one address family
                           to be activated.";
                      }
                      leaf area-address {
                        type yang:dotted-quad;
                        mandatory true;
                        description
                          "Area address.";
                      }
                      leaf metric {
                        type uint16;
                        default "1";
                        description
                          "Metric of the PE-CE link. It is used
                           in the routing state calculation and
                           path selection.";
                      }
                      leaf mtu {
                        type uint16;
                        description
                          "Maximum transmission unit for a given
                           OSPF link.";
                      }
                      leaf process-id {
                        type uint16;
                        description
                          "Process id of the OSPF CE-PE connection.";
                      }
                      container sham-links {
                        if-feature "vpn-common:rtg-ospf-sham-link";
                        description
                          "List of sham links.";
                        list sham-link {
                          key "target-site";
                          description
                            "Creates a sham link with another site.";
                          leaf target-site {
                            type vpn-common:vpn-id;
                            description
                              "Target site for the sham link connection.
                               The site is referred to by its ID.";
                          }
                          leaf metric {
                            type uint16;
                            default "1";
                            description
                              "Metric of the sham link.  It is used in
                               the routing state calculation and path
                               selection.  The default value is set
                               to 1.";
                          }
                        }
                      }
                      uses security-params;
                      uses vpn-common:service-status;
                    }
                    container isis {
                      when "derived-from-or-self(../type, "
                         + "'vpn-common:isis')" {
                        description
                          "Only applies when protocol is IS-IS.";
                      }
                      if-feature "vpn-common:rtg-isis";
                      description
                        "IS-IS specific configuration.";
                      leaf-list address-family {
                        type identityref {
                          base vpn-common:address-family;
                        }
                        min-elements 1;
                        description
                          "If IS-IS is used on this network access,
                           this node contains at least one address
                           family to be activated.";
                      }
                      leaf area-address {
                        type yang:dotted-quad;
                        mandatory true;
                        description
                          "Area address.";
                      }
                      leaf level {
                        type identityref {
                          base vpn-common:isis-level;
                        }
                        description
                          "Can be level1, level2, or level1-2.";
                      }
                      leaf metric {
                        type uint16;
                        default "1";
                        description
                          "Metric of the PE-CE link.  It is used
                           in the routing state calculation and
                           path selection.";
                      }
                      leaf process-id {
                        type uint16;
                        description
                          "Process id of the IS-IS CE-PE
                           connection.";
                      }
                      leaf mode {
                        type enumeration {
                          enum active {
                            description
                              "Interface sends or receives IS-IS
                               protocol control packets.";
                          }
                          enum passive {
                            description
                              "Suppresses the sending of IS-IS
                               updates through the specified
                               interface.";
                          }
                        }
                        default "active";
                        description
                          "IS-IS interface mode type.";
                      }
                      uses vpn-common:service-status;
                    }
                    container rip {
                      when "derived-from-or-self(../type, "
                         + "'vpn-common:rip')" {
                        description
                          "Only applies when the protocol is RIP.
                           For IPv4, the model assumes that RIP
                           version 2 is used.";
                      }
                      if-feature "vpn-common:rtg-rip";
                      description
                        "Configuration specific to RIP routing.";
                      leaf-list address-family {
                        type identityref {
                          base vpn-common:address-family;
                        }
                        min-elements 1;
                        description
                          "If RIP is used on this site, this node
                           contains at least one address family
                           to be activated.";
                      }
                      uses vpn-common:service-status;
                    }
                    container vrrp {
                      when "derived-from-or-self(../type, "
                         + "'vpn-common:vrrp')" {
                        description
                          "Only applies when protocol is VRRP.";
                      }
                      if-feature "vpn-common:rtg-vrrp";
                      description
                        "Configuration specific to VRRP.";
                      leaf-list address-family {
                        type identityref {
                          base vpn-common:address-family;
                        }
                        min-elements 1;
                        description
                          "If VRRP is used on this site, this node
                           contains at least one address family to
                           be activated.";
                      }
                      leaf vrrp-group {
                        type uint8 {
                          range "1..255";
                        }
                        description
                          "VRRP group number.";
                      }
                      leaf backup-peer {
                        type inet:ip-address;
                        description
                          "IP address of the peer";
                      }
                      leaf priority {
                        type uint8;
                        description
                          "Local priority of the VRRP speaker.";
                      }
                      leaf ping-reply {
                        type boolean;
                        description
                          "Whether the VRRP speaker should answer
                           to ping requests.";
                      }
                      uses vpn-common:service-status;
                    }
                  }
                }
                container security {
                  description
                    "Site-specific security parameters.";
                  container encryption {
                    if-feature "vpn-common:encryption";
                    description
                      "Container for CE-PE security encryption.";
                    leaf enabled {
                      type boolean;
                      default "false";
                      description
                        "If true, traffic encryption on the
                         connection is required. It is
                         disabled, otherwise.";
                    }
                    leaf layer {
                      when "../enabled = 'true'" {
                        description
                          "Indicates the layer on which encryption
                           is enabled.";
                      }
                      type enumeration {
                        enum layer2 {
                          description
                            "Encryption occurs at Layer 2.";
                        }
                        enum layer3 {
                          description
                            "Encryption occurs at Layer 3.
                             For example, IPsec may be used when
                             a customer requests Layer 3
                             encryption.";
                        }
                      }
                      description
                        "Indicates the layer on which encryption
                         is applied.";
                    }
                  }
                  container encryption-profile {
                    when "../encryption/enabled = 'true'" {
                      description
                        "Indicates the layer on which encryption
                         is enabled.";
                    }
                    description
                      "Container for encryption profile.";
                    choice profile {
                      description
                        "Choice for the encryption profile.";
                      case provider-profile {
                        leaf profile-name {
                          type leafref {
                            path "/l3vpn-ntw/vpn-profiles"
                               + "/valid-provider-identifiers"
                               + "/encryption-profile-identifier/id";
                          }
                          description
                            "Name of the service provider's profile
                             to be applied.";
                        }
                      }
                      case customer-profile {
                        leaf customer-key-chain {
                          type kc:key-chain-ref;
                          description
                            "Customer-supplied key chain.";
                        }
                      }
                    }
                  }
                }
                container service {
                  description
                    "Service parameters on the attachment.";
                  leaf svc-input-bandwidth {
                    type uint64;
                    units "bps";
                    mandatory true;
                    description
                      "From the customer site's perspective, the
                       service input bandwidth of the connection
                       or download bandwidth from the SP to
                       the site.";
                  }
                  leaf svc-output-bandwidth {
                    type uint64;
                    units "bps";
                    mandatory true;
                    description
                      "From the customer site's perspective,
                       the service output bandwidth of the
                       connection or upload bandwidth from
                       the site to the SP.";
                  }
                  leaf svc-mtu {
                    type uint16;
                    units "bytes";
                    mandatory true;
                    description
                      "MTU at service level.  If the service is IP,
                       it refers to the IP MTU.  If CsC is enabled,
                       the requested 'svc-mtu' leaf will refer
                        to the MPLS MTU and not to the IP MTU.";
                  }
                  container qos {
                    if-feature "vpn-common:qos";
                    description
                      "QoS configuration.";
                    container qos-classification-policy {
                      description
                        "Configuration of the traffic classification
                         policy.";
                      uses vpn-common:qos-classification-policy;
                    }
                    container qos-profile {
                      description
                        "QoS profile configuration.";
                      list qos-profile {
                        key "profile";
                        description
                          "QoS profile.
                           Can be standard profile or customized
                           profile.";
                        leaf profile {
                          type leafref {
                            path "/l3vpn-ntw/vpn-profiles"
                               + "/valid-provider-identifiers"
                               + "/qos-profile-identifier/id";
                          }
                          description
                            "QoS profile to be used.";
                        }
                        leaf direction {
                          type identityref {
                            base vpn-common:qos-profile-direction;
                          }
                          default "vpn-common:both";
                          description
                            "The direction to which the QoS profile
                             is applied.";
                        }
                      }
                    }
                  }
                  container carrierscarrier {
                    if-feature "vpn-common:carrierscarrier";
                    description
                      "This container is used when the customer
                       provides MPLS-based services.  This is
                       only used in the  case of CsC (i.e., a
                       customer builds an MPLSservice using an
                       IP VPN to carry its traffic).";
                    leaf signalling-type {
                      type enumeration {
                        enum ldp {
                          description
                            "Use LDP as the signalling protocol
                             between the PE and the CE.  In this
                             case, an IGP routing protocol must
                             also be activated.";
                        }
                        enum bgp {
                          description
                            "Use BGP as the signalling protocol
                             between the PE and the CE.
                             In this case, BGP must also be configured
                             as the routing protocol.";
                          reference
                            "RFC 8277: Using BGP to Bind MPLS Labels
                                       to Address Prefixes";
                        }
                      }
                      default "bgp";
                      description
                        "MPLS signalling type.";
                    }
                  }
                  container multicast {
                    if-feature "vpn-common:multicast";
                    description
                      "Multicast parameters for the site.";
                    leaf site-type {
                      type enumeration {
                        enum receiver-only {
                          description
                            "The site only has receivers.";
                        }
                        enum source-only {
                          description
                            "The site only has sources.";
                        }
                        enum source-receiver {
                          description
                            "The site has both sources and
                             receivers.";
                        }
                      }
                      default "source-receiver";
                      description
                        "Type of multicast site.";
                    }
                    leaf address-family {
                      type identityref {
                        base vpn-common:address-family;
                      }
                      description
                        "Address family.";
                    }
                    leaf protocol-type {
                      type enumeration {
                        enum host {
                          description
                            "Hosts are directly connected to the
                             provider network.

                             Host protocols such as IGMP or MLD are
                             required.";
                        }
                        enum router {
                          description
                            "Hosts are behind a customer router.
                             PIM will be implemented.";
                        }
                        enum both {
                          description
                            "Some hosts are behind a customer router,
                             and some others are directly connected
                             to the provider network.  Both host and
                             routing protocols must be used.

                             Typically,  IGMP and PIM will be
                             implemented.";
                        }
                      }
                      default "both";
                      description
                        "Multicast protocol type to be used with
                         the customer site.";
                    }
                    leaf remote-source {
                      type boolean;
                      default "false";
                      description
                        "When true, there is no PIM adjacency on
                         the interface.";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
<CODE ENDS> 
]]></artwork>
      </figure>
    </section>

    <section anchor="IANA" title="IANA Considerations">
      <t>This document requests IANA to register the following URI in the "ns"
      subregistry within the "IETF XML Registry" <xref
      target="RFC3688"></xref>:</t>

      <t><figure>
          <artwork><![CDATA[      URI: urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw
      Registrant Contact: The IESG.
      XML: N/A; the requested URI is an XML namespace.
]]></artwork>
        </figure></t>

      <t>This document requests IANA to register the following YANG module in
      the "YANG Module Names" subregistry <xref target="RFC6020"></xref>
      within the "YANG Parameters" registry.</t>

      <t><figure>
          <artwork><![CDATA[      name: ietf-l3vpn-ntw
      namespace: urn:ietf:params:xml:ns:yang:ietf-l3vpn-ntw
      maintained by IANA: N
      prefix: l3nm
      reference: RFC XXXX
]]></artwork>
        </figure></t>
    </section>

    <section anchor="Security" title="Security Considerations">
      <t>The YANG module specified in this document defines schema for data
      that is designed to be accessed via network management protocols such as
      NETCONF <xref target="RFC6241"></xref> or RESTCONF <xref
      target="RFC8040"></xref> . The lowest NETCONF layer is the secure
      transport layer, and the mandatory-to-implement secure transport is
      Secure Shell (SSH) <xref target="RFC6242"></xref>. The lowest RESTCONF
      layer is HTTPS, and the mandatory-to-implement secure transport is TLS
      <xref target="RFC8466"></xref>.</t>

      <t>The Network Configuration Access Control Model (NACM) <xref
      target="RFC8341"></xref> provides the means to restrict access for
      particular NETCONF or RESTCONF users to a preconfigured subset of all
      available NETCONF or RESTCONF protocol operations and content.</t>

      <t>The "ietf-l3vpn-ntw" module is used to manage Layer 3 VPNs in a
      service provider backbone network. Hence, the module can be used to
      request, modify, or retrieve L3VPN services. For example, the creation
      of a 'vpn-service' leaf instance triggers the creation of an L3VPN
      Service in a service provider network.</t>

      <t>Due to the foreseen use of the "ietf-l3vpn-ntw" module, there are a
      number of data nodes defined in the module that are
      writable/creatable/deletable (i.e., config true, which is the default).
      These data nodes MAY be considered sensitive or vulnerable in some
      network environments. Write operations (e.g., edit-config) and delete
      operations to these data nodes without proper protection or
      authentication can have a negative effect on network operations. These
      are the subtrees and data nodes and their sensitivity/vulnerability in
      the "ietf-l3vpn-ntw" module: <list style="symbols">
          <t>'vpn-service': An attacker who is able to access network nodes
          can undertake various attacks, such as deleting a running L3VPN
          Service, interrupting all the traffic of a client. In addition, an
          attacker may modify the attributes of a running service (e.g., QoS,
          bandwidth, routing protocols), leading to malfunctioning of the
          service and therefore to SLA violations. In addition, an attacker
          could attempt to create a L3VPN Service or adding a new network
          access. Such activity can be detected by adequately monitoring and
          tracking network configuration changes.</t>
        </list></t>

      <t>Some of the readable data nodes in the "ietf-l3vpn-ntw" module may be
      considered sensitive or vulnerable in some network environments. It is
      thus important to control read access (e.g., via get, get-config, or
      notification) to these data nodes. These are the subtrees and data nodes
      and their sensitivity/vulnerability:</t>

      <t><list style="symbols">
          <t>'customer-name' and 'ip-connection': An attacker can retrieve
          privacy-related information which can be used to track a customer.
          Disclosing such information may be considered as a violation of the
          customer-provider trust relationship.</t>
        </list></t>

      <t>The following summarizes the foreseen risks of using the
      "ietf-l3vpn-ntw" module can be classified into: <list style="symbols">
          <t>Malicious clients attempting to delete or modify VPN
          services.</t>

          <t>Unauthorized clients attempting to create/modify/delete a VPN
          service.</t>

          <t>Unauthorized clients attempting to read VPN service related
          information.</t>
        </list></t>
    </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>Thanks to Adrian Farrel and Miguel Cros for the suggestions on the
      document. Thanks to Philip Eardlay for the review. Lots of thanks for
      the discussions on opsawg mailing list and at IETF meeting.</t>

      <t>This work was supported in part by the European Commission funded
      H2020-ICT-2016-2 METRO-HAUL project (G.A. 761727).</t>
    </section>

    <section anchor="Contributors" title="Contributors">
      <t>Victor Lopez<vspace blankLines="0" /> Telefonica<vspace
      blankLines="0" /> Email: victor.lopezalvarez@telefonica.com</t>

      <t>Daniel King<vspace blankLines="0" /> Old Dog Consulting<vspace
      blankLines="0" /> Email: daniel@olddog.co.uk</t>

      <t>Daniel Voyer<vspace blankLines="0" /> Bell Canada<vspace
      blankLines="0" /> Email: daniel.voyer@bell.ca</t>

      <t>Luay Jalil<vspace blankLines="0" /> Verizon<vspace blankLines="0" />
      Email: luay.jalil@verizon.com</t>

      <t>Qin Wu<vspace blankLines="0" /> Huawei<vspace blankLines="0" />
      Email: bill.wu@huawei.com&gt;</t>

      <t>Stephane Litkowski<vspace blankLines="0" /> Cisco<vspace
      blankLines="0" /> Email: slitkows@cisco.com&gt;</t>

      <t>Manuel Julian<vspace blankLines="0" /> Vodafone<vspace
      blankLines="0" /> Email: manuel-julian.lopez@vodafone.com&gt;</t>

      <t>Lucia Oliva Ballega<vspace blankLines="0" /> Telefonica<vspace
      blankLines="0" /> Email: lucia.olivaballega.ext@telefonica.com&gt;</t>

      <t>Erez Segev<vspace blankLines="0" /> ECI Telecom<vspace
      blankLines="0" /> Email: erez.segev@ecitele.com&gt;</t>
    </section>
  </middle>

  <!--  *****BACK MATTER ***** -->

  <back>
    <!-- References split into informative and normative -->

    <!-- There are 2 ways to insert reference entries from the citation libraries:
     1. define an ENTITY at the top, and use "ampersand character"RFC2629; here (as shown)
     2. simply use a PI "less than character"?rfc include="reference.RFC.2119.xml"?> here
        (for I-Ds: include="reference.I-D.narten-iana-considerations-rfc2434bis.xml")

     Both are cited textually in the same manner: by using xref elements.
     If you use the PI option, xml2rfc will, by default, try to find included files in the same
     directory as the including file. You can also define the XML_LIBRARY environment variable
     with a value containing a set of directories to search.  These can be either in the local
     filing system or remote ones accessed by http (http://domain/dir/... ).-->

    <references title="Normative References">
      &RFC2119;

      &RFC3688;

      &RFC6020;

      &RFC7950;

      &RFC8174;

      &RFC8341;

      &RFC8040;

      &RFC6241;

      &RFC8466;

      &RFC6242;

      &RFC6991;

      &RFC8519;

      <?rfc include='reference.I-D.ietf-opsawg-vpn-common'?>

      <?rfc include='reference.RFC.4364'?>

      <?rfc include='reference.RFC.6513'?>

      <?rfc include='reference.RFC.7988'?>

      <?rfc include='reference.RFC.4110'?>

      <?rfc include='reference.RFC.6514'?>
    </references>

    <references title="Informative References">
      &RFC4026;

      &RFC8299;

      &RFC8309;

      &RFC8453;

      &RFC8340;

      <?rfc include='reference.RFC.3644'?>

      <?rfc include='reference.RFC.7149'?>

      <?rfc include='reference.RFC.7426'?>

      <?rfc include='reference.RFC.5880'?>

      <?rfc include='reference.RFC.6037'?>

      <?rfc include='reference.RFC.8342'?>

      <?rfc include='reference.I-D.ietf-idr-bgp-model'?>

      <?rfc include='reference.I-D.ietf-pim-yang'?>

      <?rfc include='reference.I-D.ietf-rtgwg-qos-model'?>

      <?rfc include='reference.RFC.4271'?>

      <?rfc include='reference.RFC.3618'?>

      <?rfc include='reference.RFC.7527'?>

      <?rfc include='reference.RFC.6982'?>

      <?rfc include='reference.RFC.8512'?>

      <?rfc include='reference.RFC.8349'?>

      <?rfc include='reference.RFC.4176'?>

      <?rfc include='reference.RFC.8345'?>

      <?rfc include='reference.RFC.8277'?>

      <reference anchor="PYANG" target="https://github.com/mbj4668/pyang">
        <front>
          <title>pyang</title>

          <author>
            <organization></organization>
          </author>

          <date month="November" year="2020" />
        </front>
      </reference>

      <?rfc include='reference.I-D.evenwu-opsawg-yang-composed-vpn'?>
    </references>

    <!-- Change Log

v00a 2019-03-27  EBD   Initial version
v00b 2019-05-07 Oscar: Comments from Bell Canada added
v00c 2019-05-21 Oscar: Comments from Vodafone added
v01  2019-07-08 Oscar: Comments from git solved
v02a 2019-08-23 Samier: Yang fixed.
v02b 2019-09-19 Daniel King: Review.
v02c 2019-09-24 Oscar and Samier: Review+Yang fix.
VIETF01 2019-11-17 Oscar, Samier, Med, Stephane, Alejandro.
 -->

    <section anchor="examples" title="L3VPN Examples">
      <t><!--Med: Add IPv6 Examples and use documentattion addresses--></t>

      <section anchor="mbh-vpn" title="4G VPN Provisioning Example">
        <t>L3VPNs are widely used to deploy 3G/4G, fixed, and enterprise
        services mainly because several traffic discrimination policies can be
        applied within the network to deliver to the mobile customers a
        service that meets the SLA requirements.</t>

        <t>As it is shown in the <xref target="vpn-service-mbh"></xref>,
        typically, an eNodeB (CE) is directly connected to the access routers
        of the mobile backhaul and their logical interfaces (one or many
        according to the Service type) are configured in a VPN that transports
        the packets to the mobile core platforms. In this example, a
        'vpn-node' is created with two 'vpn-network-accesses'.</t>

        <figure align="center" anchor="vpn-service-mbh"
                title="Mobile Backhaul Example">
          <artwork align="left"><![CDATA[                   
      +-------------+                  +------------------+    
      |             |                  | PE               |
      |             | 192.0.2.2        |  10.0.0.1        |
      |   eNodeB    |>--------/------->|...........       | 
      |             |          Vlan 1  |          |       |
      |             |>--------/------->|......    |       |
      |             |          Vlan 2  |     |    |       |
      |             | Direct           |  +-------------+ |
      +-------------+ Routing          |  | vpn-node-id | |
                                       |  | 44          | | 
                                       |  +-------------+ |        
                                       |                  | 
                                       +------------------+ 
     ]]></artwork>
        </figure>

        <t>To create a L3VPN service using the L3NM model, the following
        sample steps can be followed:</t>

        <t>First: Create the 4G VPN Service (<xref
        target="service-mbh2"></xref>).</t>

        <figure align="center" anchor="service-mbh2"
                title="Create VPN Service">
          <artwork align="left"><![CDATA[POST: /restconf/data/ietf-l3vpn-ntw:l3vpn-ntw/vpn-services
Host: example.com
Content-Type: application/yang-data+json

{
  "ietf-l3vpn-ntw:vpn-services": {
    "vpn-service": [
      {
        "vpn-id": "4G",
        "customer-name": "mycustomer",
        "vpn-service-topology": "custom",
        "description": "VPN to deploy 4G services"
      }
    ]
  }
}
]]></artwork>
        </figure>

        <t>Second: Create a VPN Node as depicted in <xref
        target="service-mbh3"></xref>. In this type of service, the VPN Node
        is equivalent to the VRF configured in the physical device
        ('ne-id'=10.0.0.1).</t>

        <figure align="center" anchor="service-mbh3" title="Create VPN Node">
          <artwork align="left"><![CDATA[POST: /restconf/data/ietf-l3vpn-ntw:l3vpn-ntw/\
      vpn-services/vpn-service=4G    
Host: example.com
Content-Type: application/yang-data+json

{
  "ietf-l3vpn-ntw:vpn-nodes": {
    "vpn-node": [
      {
        "vpn-node-id": "44",
        "ne-id": "10.0.0.1",
        "local-autonomous-system": "65550",
        "rd": "0:65550:1",
        "vpn-targets": {
          "vpn-target": [
            {
              "id": "1",
              "route-targets": [
                "0:65550:1"
              ],
              "route-target-type": "both"
            }
          ]
        }
      }
    ]
  }
}  ]]></artwork>
        </figure>

        <t>Finally, two VPN Network Accesses are created using the same
        physical port ('port-id'=1/1/1). Each 'vpn-network-access' has a
        particular VLAN (1,2) to differentiate the traffic between: Sync and
        data (<xref target="service-mbh4"></xref>).</t>

        <figure align="center" anchor="service-mbh4"
                title="Create VPN Network Access">
          <artwork align="left"><![CDATA[POST: /restconf/data/ietf-l3vpn-ntw:l3vpn-ntw/\
      vpn-services/vpn-service=4G/vpn-nodes/vpn-node=44
content-type: application/yang-data+json

{
  "ietf-l3vpn-ntw:vpn-network-accesses": {
    "vpn-network-access": [
      {
        "vpn-network-access-id": "1/1/1.1",
        "port-id": "1/1/1",
        "description": "Interface SYNC to eNODE-B",
        "status": {
          "admin-enabled": "true"
        },
        "vpn-network-access-type": "vpn-common:point-to-point",
        "ip-connection": {
          "ipv4": {
            "address-allocation-type": "static-address",
            "static-addresses": {
              "primary-address": "1",
              "address": [
                {
                  "address-id": "1",
                  "s-provider-address": "192.0.2.1",
                  "s-customer-address": "192.0.2.1",
                  "s-prefix-length": 32
                }
              ]
            }
          }
        },
        "routing-protocols": {
          "routing-protocol": [
            {
              "id": "1",
              "type": "vpn-common:direct"
            }
          ]
        }
      },
      {
        "vpn-network-access-id": "1/1/1.2",
        "port-id": "1/1/1",
        "description": "Interface DATA to eNODE-B",
        "status": {
          "admin-enabled": "true"
        },
        "ip-connection": {
          "ipv4": {
            "address-allocation-type": "static-address",
            "static-addresses": {
              "primary-address": "1",
              "address": [
                {
                  "address-id": "1",
                  "s-provider-address": "192.0.2.1",
                  "s-customer-address": "192.0.2.2",
                  "s-prefix-length": 32
                }
              ]
            }
          }
        },
        "routing-protocols": {
          "routing-protocol": [
            {
              "id": "1",
              "type": "vpn-common:direct"
            }
          ]
        }
      }
    ]
  }
}    ]]></artwork>
        </figure>
      </section>

      <section anchor="multicast_vpn_example"
               title="Multicast VPN Provisioning Example">
        <t>IPTV is mainly distributed through multicast over the LANs. In the
        following example, PIM-SM is enabled and functional between the PE and
        the CE. The PE receives multicast traffic from a CE that is directly
        connected to the multicast source. The signaling between PE and CE is
        achieved using BGP. Also, RP is statically configured for a multicast
        group.</t>

        <figure align="center" anchor="service-mc1"
                title="Multicast L3VPN Service Example">
          <artwork align="left"><![CDATA[                                                        
              +-----------+   +------+     +------+    +-----------+
              | Multicast |---|  CE  |--/--|  PE  |----|  Backbone |
              |  source   |   +------+     +------+    |   IP/MPLS |
              +-----------+                            +-----------+
        
            ]]></artwork>
        </figure>

        <t>To configure a Multicast L3VPN service using the L3NM model the
        procedure and the JSON with the data structure is the following:</t>

        <t>First, the multicast service is created (see the excerpt of the
        request message body shown in <xref target="service-mc2"></xref>)</t>

        <figure align="center" anchor="service-mc2"
                title=" Create Multicast VPN Service (Excerpt of the Message Request Body)">
          <artwork align="left"><![CDATA[             
{
  "ietf-l3vpn-ntw:vpn-services": {
    "vpn-service": [
      {
        "vpn-id": "Multicast-IPTV",
        "customer-name": "310",
        "vpn-service-topology": "vpn-common:hub-spoke",
        "description": "Multicast IPTV VPN service"
      }
    ]
  }
}
]]></artwork>
        </figure>

        <t>Then, the VPN nodes are created (see the excerpt of the request
        message body shown in <xref target="service-mc3"></xref>). In this
        example, the VPN Node will represent VRF configured in the physical
        device.</t>

        <figure align="center" anchor="service-mc3"
                title="Create Multicast VPN Node (Excerpt of the Message Request Body)">
          <artwork align="left"><![CDATA[            
{
  "ietf-l3vpn-ntw:vpn-node": [
    {
      "vpn-node-id": "500003105",
      "ne-id": "10.250.2.202",
      "autonomous-system": "3816",
      "description": "VRF_IPTV_MULTICAST",
      "router-id": "10.250.2.202",
      "address-family": "ipv4",
      "node-role": "vpn-common:hub-role",
      "rd": "3816:31050202",
      "multicast": {
        "enabled": "true",
        "rp": {
          "rp-group-mappings": {
            "rp-group-mapping": [
              {
                "id": "1",
                "rp-address": "172.19.48.17",
                "groups": {
                  "group": [
                    {
                      "id": "1",
                      "group-address": "239.130.0.0/15"
                    }
                  ]
                }
              }
            ]
          },
          "rp-discovery": {
            "rp-discovery-type": "vpn-common:static-rp"
          }
        }
      }
    }
  ]
}         ]]></artwork>
        </figure>

        <t>Finally, create the VPN Network Access with multicast enabled (see
        the excerpt of the request message body shown in <xref
        target="service-mc4"></xref>).</t>

        <figure align="center" anchor="service-mc4"
                title="Create VPN Network Access (Excerpt of the Message Request Body)">
          <artwork align="left"><![CDATA[   
 {
  "ietf-l3vpn-ntw:vpn-network-access": {
    "vpn-network-access-id": "1/1/1",
    "description": "Connected_to_source",
    "status": {
      "admin-enabled": "true"
    },
    "vpn-network-access-type": "vpn-common:point-to-point",
    "ip-connection": {
      "ipv4": {
        "address-allocation-type": "static-address",
        "static-addresses": {
          "primary-address": "1",
          "address": [
            {
              "address-id": "1",
              "s-provider-address": "172.19.48.1",
              "s-prefix-length": 30
            }
          ]
        }
      }
    },
    "routing-protocols": {
      "routing-protocol": [
        {
          "id": "1",
          "type": "vpn-common:bgp",
          "bgp": {
            "peer-autonomous-system": "6500",
            "local-autonomous-system": "3816",
            "address-family": "ipv4",
            "neighbor": "172.19.48.2",
            "description": "Connected to CE"
          }
        }
      ]
    },
    "service": {
      "multicast": {
        "multicast-site-type": "source-only",
        "multicast-address-family": {
          "ipv4": "true"
        },
        "protocol-type": "router"
      }
    }
  }
} ]]></artwork>
        </figure>
      </section>
    </section>

    <section anchor="Implementation" title="Implementation Status">
      <t>This section records the status of known implementations of the Yang
      module defined by this specification at the time of posting of this
      Internet-Draft, and is based on a proposal described in <xref
      target="RFC6982"></xref>. The description of implementations in this
      section is intended to assist the IETF in its decision processes in
      progressing drafts to RFCs. Please note that the listing of any
      individual implementation here does not imply endorsement by the IETF.
      Furthermore, no effort has been spent to verify the information
      presented here that was supplied by IETF contributors. This is not
      intended as, and must not be construed to be, a catalog of available
      implementations or their features. Readers are advised to note that
      other implementations may exist.</t>

      <t>According to <xref target="RFC6982"></xref>, "this will allow
      reviewers and working groups to assign due consideration to documents
      that have the benefit of running code, which may serve as evidence of
      valuable experimentation and feedback that have made the implemented
      protocols more mature. It is up to the individual working groups to use
      this information as they see fit".</t>

      <t>Note the RFC Editor: As per <xref target="RFC6982"></xref>
      guidelines, please remove this Implementation Status apendix prior
      publication.</t>

      <section title="Nokia Implementation">
        <t>Details can be found at:
        https://github.com/IETF-OPSAWG-WG/l3nm/blob/master/Implementattion/Nokia.txt</t>
      </section>

      <section title="Huawei Implementation">
        <t>Details can be found at:
        https://github.com/IETF-OPSAWG-WG/l3nm/blob/master/Implementattion/Huawei.txt</t>
      </section>

      <section title="Infinera Implementation">
        <t>Details can be found at:
        https://github.com/IETF-OPSAWG-WG/l3nm/blob/master/Implementattion/Infinera.txt</t>
      </section>

      <section title="Ribbon-ECI Implementation">
        <t>Details can be found at:
        https://github.com/IETF-OPSAWG-WG/l3nm/blob/master/Implementattion/Ribbon-ECI.txt</t>
      </section>
    </section>
  </back>
</rfc>
